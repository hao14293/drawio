# 学习笔记

## 感知服务详细设计文档

感知服务包含人、车、结构化、步态相关业务

<img src="C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240717090237595.png" alt="image-20240717090237595" style="zoom: 200%;" />

| **业务类型**   | **主要功能**                                                 |
| -------------- | ------------------------------------------------------------ |
| 人脸智能业务   | 注册库管理、库成员管理、实时图片流分析、布控管理、以图搜图、1V1比对、NVN库碰撞比对 |
| 车辆智能业务   | 实时图片流分析、以图搜图                                     |
| 结构化智能业务 | 实时图片流分析、实时视频流分析、录像分析、预案任务分析、以图搜图 |
| 步态业务       | 注册库管理、库成员管理、实时视频流分析、实时图片流分析、录像分析、布控管理、以图搜图 |
| 事件业务       | 实时视频流分析、实时图片流分析、录像分析误报库管理           |



| **服务名称**             | **服务简介**                                                 | **Git****仓库名称**     | **技术栈** | **主要负责人** |
| ------------------------ | ------------------------------------------------------------ | ----------------------- | ---------- | -------------- |
| CVEngine-Business        | 网关服务：北向统一对各服务平台提供https服务，转发至内部其他业务服务模块 | **CVEngine-gateway**    | go         | 饶平           |
| CVEngine-Maintainer      | 配置中心：管理和分发视图智能集群中各服务的配置信息  注册中心：管理集群中各服务信息；集群各服务向注册中心注册本服务信息，订阅所依赖服务的信息 | **maintainer**          | java       | 赵晨时、曹敏   |
| CVEngine-ResourceManager | 资源管理模块：管理智能算力资源，包括硬件资源和智能算子资源   | **ResourceManager**     | java       | 赵晨时、曹敏   |
| CVEngine-MPlatform       | 中台（算法仓库）服务：管理算法包、算子包、算法、智能网络资源等信息 | **CVEngine-library**    | java       | 张广领、孟红全 |
| CVEngine-Perception      | 感知服务：对外提供人脸智能业务、车辆智能业务、结构化智能、步态智能业务服务 | **CVEngine-Perception** | java       | 赵晨时、曹敏   |
| CVEngine-Cognition       | 认知服务：对外提供事件智能业务服务、大模型智能业务服务       | **CVEngine-cognition**  | java       | 吴林俊、黄强   |
| CVEngine-Actuator        | 智能运维服务：面向技术支持快速排查问题，针对集群内各类日志、异常及数据关系做运维展示 | **CVEngine-Actuator**   | java       | 曹敏           |

| **服务名称**      | **服务简介**                                                 | **Git****仓库名称** | **技术栈** | **主要负责人**   |
| ----------------- | ------------------------------------------------------------ | ------------------- | ---------- | ---------------- |
| CVEngine-Executor | 数据级联服务：分发流转各类智能相关数据，如将已开启分析的抓拍数据分发给具有对应智能分析能力的算子 | Executor            | go         | 饶平、建辉、广领 |
| CVEngine-Agent    | 调度子节点服务：收集硬件信息上报给资源管理服务；管理智能算子进程 | Agent               | java       | 赵晨时           |
| CVEngine-Feature  | 特征存储服务：存储特征值及注册库图片；也可临时存储抓拍库图片 | pf                  | java       | 董雨轩、方彪     |
| CVEngine-Redis    | 目前存储了图搜结果信息、静态库分片信息及一些智能运维所需数据 |                     | 开源       | 万光宝           |
| 公共脚本          | 安装部署、升级等功能的公共脚本                               | cvengine-tool       | shell      | 庄建辉           |

## 总体工程设计

![image-20240717090449871](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240717090449871.png)

Deploy为启动模块

Common 模块为所有模块的公共依赖部分

DataBase模块为sql相关

Ha 模块为主备

Rpc模块为grpc相关

Core模块为人车结构化步态公共业务模块

其余功能模块分为api部分与Service 部分，便于后期拆解转换为dubbo



## Deploy模块

### 鉴权修改

感知服务不再实现鉴权功能，但是仍然需要获取ak sk uid等用户信息。 此功能改为通过business 网关服务获取。
  具体实现可参看AuthInfoAop，直接从网关转发的请求头中获取。

```
/**
 *  Perception的鉴权 没有用MaintainerClient 中的接口，所以配置中都为false
 *  自己在Aop中实现了新的鉴权逻辑,因为网关已经比较了认证信息了，这里没有必要再生成与比较一次
 *
 *  但是还是留一个后门配置，可以关闭鉴权，即允许请求不带ak sk uid信息
 */
```



```java
// AuthInfoAop.java
使用Spring AOP（Aspect Oriented Programming，面向切面编程）来实现一个权限验证的切面（Aspect）。

@Aspect // 标记此类为一个切面，用于横切关注点的模块化，如日志、事务、权限验证等。
@Order(value = 100) // 定义此切面的优先级，数值越小优先级越高。在有多个切面时，决定它们的执行顺序。
@Component // 将此类声明为Spring容器管理的组件，使得切面可以被自动识别和加载。
@Slf4j // Lombok注解，自动生成日志对象log，简化日志代码的编写。
public class AuthInfoAop {

    @Autowired 
    private AuthInfoImpl authInfoImpl;
    @Autowired 
    private CommonProperties commonProperties;

    // 定义一个切点（Pointcut），指定此切面将作用于哪些方法上。
    @Pointcut("execution(* com.dahuatech.cvengine.perception.*.controller..*(..)) " + // 
            "&& !execution(* com.dahuatech.cvengine.perception.support.controller.RepositoryRedistributeController.*(..))") // 切点排除RepositoryRedistributeController下的所有方法。
    public void pointcut() { // 空方法，仅作为切点的标识。
    }

    @Around(value = "pointcut()") // 定义一个环绕通知（Around Advice），在匹配的方法调用前后执行。
    public Object around(ProceedingJoinPoint pjo) throws Throwable { // 声明around方法，参数pjo是一个代理点（ProceedingJoinPoint），代表即将被调用的方法。

        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); // 从当前线程中获取HttpServletRequest对象，用于读取HTTP请求头信息。

        AuthInfo authInfo = new AuthInfo(); // 创建AuthInfo对象，用于存储权限验证所需的信息。

        String userId = request.getHeader("userId"); // 从请求头中获取用户ID。
        String userAk = request.getHeader("userAk"); // 从请求头中获取用户的Access Key ID。
        String userSk = request.getHeader("userSk"); // 从请求头中获取用户的Secret Access Key。

        // 网关关闭鉴权，会发送一个userId为-1的请求头。
        if(!StringUtils.isEmpty(userId) && userId.equals("-1")){ // 如果用户ID存在且等于"-1"，表示网关关闭了鉴权。
            authInfoImpl.notifyAuthInfo((AuthInfo) null); // 调用AuthInfoImpl的notifyAuthInfo方法，传入null表示无需权限验证。
            return pjo.proceed(); // 继续执行原方法。
        }

        if (StringUtils.isEmpty(userId) || StringUtils.isEmpty(userAk) || StringUtils.isEmpty(userSk)) { // 检查用户ID、Access Key ID和Secret Access Key是否为空。
            throw new AppException("vcsAuthError", "auth failed"); // 如果缺少任何一项，则抛出AppException，表示权限验证失败。
        }
        
        authInfo.setUserId(Integer.valueOf(userId)); // 设置AuthInfo对象的用户ID。
        authInfo.setAccessKeyId(userAk); // 设置AuthInfo对象的Access Key ID。
        authInfo.setSecretAccessKey(userSk); // 设置AuthInfo对象的Secret Access Key。
        
        authInfoImpl.notifyAuthInfo(authInfo); // 调用AuthInfoImpl的notifyAuthInfo方法，传入填充好的AuthInfo对象进行权限验证。
        
        return pjo.proceed(); // 权限验证通过后，继续执行原方法。
    }
}

//定义了一个权限验证的切面，它会在指定的控制器方法调用前检查HTTP请求头中的权限信息，如果验证通过则允许方法继续执行；如果验证失败或网关指示无需验证，则会相应地抛出异常或直接放行。
```

## DataBase 模块

Database模块现在由一种mapper生成工具统一生成，所有的sql写法也都做了统一处理。 以后如果要修改，新增表，务必使用相同的工具生成。此工具存放在此模块test目录下，已经配置好，稍加修改执行即可。

```md
MybatisGenerator 

也可以使用idea的MybatisX插件自动生成
```

## 库管理

为了将所有的成员分门别类存放，便于后续识别、查找、布控，提供库管理功能，包含创建、修改、删除、查询等操作。不同成员存在意义不同，有些成员可以用来布控告警，有些成员只需要检索， 因此将库分为不同类型，提供不同作用。库类型分为黑名单、白名单、静态库。

黑名单、白名单：目前功能一致，提供检索及布控，告警算子、检索算子均需要加载所有黑名单、白名单

静态库：提供检索功能，检索算子加载；由于一般静态库成员较多，亿级别以上，若均加载在一个检索算子，会急剧消耗该算子内存，且检索性能低下；因此，对于静态库成员特征会进行分片存储，每个检索算子加载某些分片，尽量均衡

目前只有人脸、步态具有库管理功能，包含创建、修改、删除、查询操作。

约束条件：

l  库名称以及REPOSITORY_RECORD_ID不允许重复（不包括待删除的）

l  存在布控、通道分析挂载的抓拍库、聚类库不允许删除

l  名词解释汇总

| **库类型** | **描述**                   |
| ---------- | -------------------------- |
| 0          | 黑名单（布控库）（注册库） |
| 1          | 白名单（布控库）（注册库） |
| 2          | 静态库（注册库）           |
| 3          | 抓拍库                     |
| 4          | 路人库or聚类库             |
| 5          | 全局新建档库               |
| 99         | 通用类                     |

 ```java
public enum RepositoryType {
    /**
     * 黑名单
     */
    BLOCKLIST(0),
    /**
     * 白名单
     */
    ALLOWLIST(1),
    /**
     * 静态库
     */
    STATIC(2),
    /**
     * 抓拍库or路人库
     */
    CAPTURE(3),
    /**
     * 聚类库
     */
    PASSERBY(4),
    /**
     * 全局新建档库
     */
    GLOBALREPO(5),
    /**
     * 通用类
     */
    COMMON(99),;
}
 ```



### 1. 人像库业务功能

#### Repository数据表

![repository](C:\Users\485322\Documents\repository.png)



![image-20240717100231910](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240717100231910.png)

##### Model（POJO）

```java
// model
public class Repository extends BaseModel {
    /** 人像库ID */
    private Integer repositoryId;
    /** 人像库记录ID */
    private String repositoryRecordId;
    /** 库名称 */
    private String repositoryName;
    /** 库类型 */
    private Integer repositoryType;
    /** 备注 */
    private String memo;
    /** 创建时间 */
    private Long createtime;
    /** 更新时间 */
    private Long updatetime;
    /** 记录状态 */
    private Integer state;
    /** 版本号 */
    private Integer operationVersion;
    /** 用户ID */
    private Integer uid;
    /** 业务类型  1：face   2：车辆  4：结构化   8：缩略图 */
    private Integer businessType;
    /** 库生命周期 */
    private int lifeCycle;
}
```

##### Dto

```java
public class RepositoryDto {
    private String requestId;
    private Integer repositoryId;
    private String repositoryRecordId;
    private Integer serialNum;
    private String channelId;
    private String regionId;
}
```

##### Mapper

```java
public interface RepositoryMapper {
    /**
     *  根据指定的条件获取数据库记录数,REPOSITORY
     */
    int countByExample(RepositoryExample example);
    /**
    public class RepositoryExample {
        // 排序字段,REPOSITORY
        protected String orderByClause;
        // 是否过滤重复数据,REPOSITORY
        protected boolean distinct;
        protected List<Criteria> oredCriteria;
    }
    */
    /**
     *  根据指定的条件删除数据库符合条件的记录,REPOSITORY
     */
    int deleteByExample(RepositoryExample example);
    /**
     *  根据主键删除数据库的记录,REPOSITORY
     */
    int deleteByPrimaryKey(Integer repositoryId);
    /**
     *  新写入数据库记录,REPOSITORY
     */
    int insert(Repository record);
    /**
     *  动态字段,写入数据库记录,REPOSITORY
     */
    int insertSelective(Repository record);
    /**
     *  根据指定的条件查询符合条件的数据库记录,REPOSITORY
     */
    List<Repository> selectByExample(RepositoryExample example);
    /**
     *  根据指定主键获取一条数据库记录,REPOSITORY
     */
    Repository selectByPrimaryKey(Integer repositoryId);
    /**
     *  动态根据指定的条件来更新符合条件的数据库记录,REPOSITORY
     */
    int updateByExampleSelective(@Param("record") Repository record, @Param("example") RepositoryExample example);
    /**
     *  根据指定的条件来更新符合条件的数据库记录,REPOSITORY
     */
    int updateByExample(@Param("record") Repository record, @Param("example") RepositoryExample example);
    /**
     *  动态字段,根据主键来更新符合条件的数据库记录,REPOSITORY
     */
    int updateByPrimaryKeySelective(Repository record);
    /**
     *  根据主键来更新符合条件的数据库记录,REPOSITORY
     */
    int updateByPrimaryKey(Repository record);
}
```



```java
public interface RepositoryExtMapper extends RepositoryMapper {

    List<Repository> selectDelRepositoryByPage(Integer repositoryId);

// 查询满足多个条件的Repository实体，并将结果按照分页的形式返回
    Page<Repository> selectByIds(Page<Repository> page, @Param("ids") List<String> ids, @Param("type") Integer type, @Param("name") String name,
                                 @Param("businessType") Integer businessType, @Param("uid") Integer uid);

    int insertBatch(@Param("list") List<Repository> list);

    List<Repository> selectCaptureRepositoryByResourceId(Integer resourceId);

    List<Integer> queryRepositoryIdByType(@Param("type") Integer type);

    List<Repository> getRepositorysByPrimaryKeys(@Param("repositoryIds") List<Integer> repositoryIds);

    List<Repository> selectSurveillanceRepositoryIdsByResourceId(Integer resourceId);

    List<Repository> selectTaskRepositoryIdsByResourceId(Integer resourceId);

    List<Integer> selectAllSurveillanceRepository();

    List<IdAndType> selectAllSurveillanceRepositoryIdAndType(@Param("businessType") Integer businessType);

    /**
     * 查询全局新建档案库,如果对应的算子状态是stop则不会返回算子信息.
     *
     * @return 返回已存在的全局新建档案库或NULL
     */
    Repository selectGlobalNewRepository();

    Repository selectGlobalNewRepositoryByType();

    int deleteByRecordId(String recordId);

    /**
     * 根据业务类型和资源类型查找没有绑定冷搜算子的抓拍库
     *
     * @param businessType
     * @param resourceType
     * @return
     */
    List<Repository> selectUnbindColdRetrievalResourceCapture(@Param("businessType") Integer businessType, @Param("resourceType") Integer resourceType);

    /**
     * 删除所有数据
     */
    void deleteAll();

    Integer updateRepoByRepositoryId(@Param("repository") Repository repository);

    Integer updateDelRepoByRepositoryId(@Param("repository") Repository repository);

    Integer batchUpdateDelRepoByRepositoryIds(@Param("repositories") List<Repository> repositories);

    Repository selectRepositoryByRepositoryRecordId(@Param("repositoryRecordId") String repositoryRecordId, @Param("uid") int uid);

    List<Repository> selectRepositoryByRepositoryId(@Param("repositoryIds") List<Integer> repositoryIds, @Param("uid") int uid);
    List<Repository> selectAllRepositoryByRepositoryId(@Param("repositoryIds") List<Integer> repositoryIds, @Param("uid") int uid);
    List<Repository> selectAllRepositoryByRepositoryRecordId(@Param("repositoryIds") List<String> repositoryIds, @Param("uid") int uid);

    Repository selectByName(@Param("repositoryName") String repositoryName);

    Repository selectByNameOrRecordId(@Param("repositoryName") String repositoryName, @Param("recordId") String recordId);

    List<Repository> queryIfExistNameOrRecordId(@NotNull @Param("repositoryNames") List<String> repositoryNames,
                                                @NotNull @Param("recordIds") List<String> recordIds);

    Integer updateRepoStatus(@Param("repository") Repository repository);

    RepositorySearchInfo selectMemRepoByRepositoryRecordId(@Param("repositoryRecordId") String repositoryRecordId);

    List<RepositorySearchInfo> selectAvailableByRepositoryRecordId(
            @Param("repostioryRecordIds") List<String> repostioryRecordIds);

    /**
     * 查询单个人像库信息，除了人像库本身的信息外还包含了一些其他的信息
     *
     * @param repositoryId 要查询的人像库的主键id
     * @return 该id对应的人像库的信息
     */
    RepositorySearchInfo selectAvailableByRepositoryId(@Param("repositoryId") Integer repositoryId);

    Integer selectCount(@Param("start") Integer start,
                        @Param("limit") Integer limit, @Param("type") Integer type, @Param("name") String name,
                        @Param("key") String key, @Param("uid") Integer uid);


    List<RepositorySearchInfo> selectAll(@Param("start") Integer start,
                                         @Param("limit") Integer limit, @Param("type") Integer type, @Param("name") String name,
                                         @Param("key") String key, @Param("uid") Integer uid);


    List<RepositorySetInfo> selectFaceSetInfoByIds(
            @Param("repostioryRecordIds") List<String> repostioryRecordIds, @Param("uid") Integer uid);


    List<RepositorySetInfo> selectFaceSetInfo(@Param("start") Integer start,
                                              @Param("limit") Integer limit, @Param("type") Integer type,
                                              @Param("name") String name, @Param("key") String key, @Param("uid") Integer uid);


    /**
     * 查询满足条件的库信息
     *
     * @param repositoryRecordId 库ID 必填
     * @param businessType       业务类型
     * @param types              库类型
     */
    RepositorySearchInfo selectRepoByRepositoryRecordId(
            @Param("repositoryRecordId") String repositoryRecordId,
            @Param("businessType") Integer businessType, @Param("types") List<Integer> types,
            @Param("uid") Integer uid);


    List<RepositorySearchInfoUnCount> selectAllRepositoryByParam(@Param("start") Integer start,
                                                                 @Param("limit") Integer limit, @Param("repositoryTypes") List<String> repositoryTypes,
                                                                 @Param("name") String name,
                                                                 @Param("key") String key, @Param("businessType") Integer businessType,
                                                                 @Param("uid") Integer uid);

    /**
     * 库个数统计，剔除状态为-1，-2的库,
     *
     * @param types 库类型集合
     */
    int queryRepositoryReloadCount(@Param("types") List<Integer> types);

    /**
     * 用于加载库内存信息
     *
     * @param types 库类型集合
     */
    List<RepositoryReloadInfo> queryRepositoryReloadInfo(@Param("start") Integer start,
                                                         @Param("limit") Integer limit,
                                                         @Param("types") List<Integer> types);


    Repository selectByRecordId(@Param("repositoryRecordId") String repositoryRecordId, @Param("uid") Integer uid);

    Repository selectByPrimaryKeyAndUid(@Param("repositoryId") Integer repositoryId, @Param("uid") Integer uid);

    Repository selectByRecordIdAndBusinessType(@Param("repositoryRecordId") String repositoryRecordId,
                                               @Param("uid") Integer uid, @Param("businessType") Integer businessType);


    List<Repository> selectRepositoryByRepositoryRecordIdsBusinessTypeUid(@Param("repositoryRecordIds") List<String> repositoryRecordIds,
                                                                           @Param("businessType") Integer businessType,
                                                                           @Param("uid") Integer uid);

    List<Repository> selectByRepositoryType(@Param("types") List<Integer> types);

    void deleteBatchIds(@Param("repositoryIds") List<Integer> repositoryIds);

    List<Repository> selectByRepositoryRecordIds(@Param("repositoryRecordIds") List repositoryRecordIds,
                                                 @Param("businessType") Integer businessType);

    List<Repository> selectByRepositoryIdsAndUid(@Param("repositoryIds") Set<Integer> repositoryIds,@Param("uid") Integer uid);

    List<AlarmRouteRepInfo> selectAllAlarmRouteRepInfo();

    Repository selectByRepositoryRecordId(String repositoryRecordId);

```



##### Dao

```java
@Slf4j
@Component
public class RepositoryDao {
    @Autowired
    RepositoryExtMapper repositoryExtMapper;

    public List<Repository> selectRepositoryNotSynced(Integer repositoryId) throws DaoException {
        try {
            //分页查询，要求repositoryId > 断点Id,一次查询20条。
            if (repositoryId == null) {
                repositoryId = 0;
            }
            List<Repository> repositories = repositoryExtMapper
                    .selectDelRepositoryByPage(repositoryId);
            if (null != repositories && repositories.size() > 0) {
                log.info("selectRepositoryNotSynced's repositories size = {}", repositories.size());
            }
            return repositories;
        } catch (Exception e) {
            log.info("selectRepositoryNotSynced error: ", e);
            throw new DaoException("selectNotSynced error", e);
        }
    }

    /**
     * 根据repositoryRecordId 查询 注册库 的库id列表
     *
     * @param repositoryIds
     * @param businessType
     * @return
     */
    public List<Repository> selectByRepositoryRecordIds(List<String> repositoryIds, BusinessType businessType) {
        if (CollectionUtils.isEmpty(repositoryIds)) {
            return new ArrayList<Repository>();
        }
        return repositoryExtMapper.selectByRepositoryRecordIds(repositoryIds, businessType.getCode());
    }

    @javax.annotation.Nullable
    public Repository selectByRepositoryRecordId(@javax.annotation.Nullable String repositoryRecordId) {
        if (null == repositoryRecordId) {
            return null;
        }
        return repositoryExtMapper.selectByRepositoryRecordId(repositoryRecordId);
    }

    public Page<Repository> queryByIds(List<String> repositoryRecordIds, Integer repositoryType, String name,
                                       Integer businessType, Integer uid, Integer currentPage, Integer pageSize) {
        Page<Repository> page = new Page<>(Optional.ofNullable(currentPage).orElse(DeepLearningConstants.DEFAULT_RESULT_START),
                Optional.ofNullable(pageSize).orElse(DeepLearningConstants.DEFAULT_RESULT_PAGESIZE));
        return repositoryExtMapper.selectByIds(page, repositoryRecordIds, repositoryType, name, businessType, uid);
    }

    @Nullable
    public Repository selectByPrimaryKeyAndUid(@NotNull Integer repositoryId, @NotNull Integer uid) {

        RepositoryExample example = new RepositoryExample();
        example.createCriteria().andUidEqualTo(uid).andRepositoryIdEqualTo(repositoryId);
        List<Repository> repositories = repositoryExtMapper.selectByExample(example);
        return CollectionUtils.isEmpty(repositories) ? null : repositories.get(0);
    }

    public Repository selectByRecordIdAndBusinessType(@org.jetbrains.annotations.NotNull String recordId, Integer uid, Integer businessType) throws DaoException {
        try {
            return repositoryExtMapper.selectByRecordIdAndBusinessType(recordId, uid, businessType);
        } catch (Exception e) {
            log.error("selectByRecordId dao error: ", e);
            throw new DaoException("selectByRecordId dao error: ", e);
        }
    }


    /**
     * 插入库记录
     * @param repository
     * @return
     */
    public int insert(Repository repository){
        return repositoryExtMapper.insert(repository);
    }


    @javax.annotation.Nullable
    public Repository selectByPrimaryKey(@javax.annotation.Nullable Integer repositoryId) {
        if (null == repositoryId) {
            return null;
        }
        return repositoryExtMapper.selectByPrimaryKey(repositoryId);
    }

    @Nullable
    public Repository selectByPrimaryKey(@Nullable Integer repositoryId, int uid) {
        if (null == repositoryId) {
            return null;
        }
        return repositoryExtMapper.selectByPrimaryKeyAndUid(repositoryId, uid);
    }

    @javax.annotation.Nullable
    public List<Repository> selectCaptureRepositoryByResourceId(@NonNull Integer resourceId) {
        return repositoryExtMapper.selectCaptureRepositoryByResourceId(resourceId);
    }

    public List<Integer> queryRepositoryIdByType(Integer type) {
        if (type != null) {
            return repositoryExtMapper.queryRepositoryIdByType(type);
        }
        return null;
    }


    public List<Repository> selectRepositorysByPrimaryKeys(List<Integer> repositoryIds)
            throws DaoException {
        if (repositoryIds.isEmpty()) {
            return null;
        }
        try {
            return repositoryExtMapper.getRepositorysByPrimaryKeys(repositoryIds);
        } catch (Exception e) {
            log.error("getRepositorysByPrimaryKeys exception: " + e);
            throw new DaoException("getRepositorysByPrimaryKeys error: " + e);
        }
    }

    /**
     * 查询算子对应的布控库id.
     *
     * @param resourceId 指定算子.
     * @return 该算子对应的布控库id.
     */
    @javax.annotation.Nullable
    public List<Repository> selectSurveillanceRepositoryIdsByResourceId(
            @org.jetbrains.annotations.NotNull Integer resourceId) {
        List<Repository> repositories = repositoryExtMapper
                .selectSurveillanceRepositoryIdsByResourceId(resourceId);
        if (CollectionUtils.isEmpty(repositories)) {
            return null;
        } else {
            return repositories;
        }
    }

    @javax.annotation.Nullable
    public List<Repository> selectTaskRepositoryIdsByResourceId(@org.jetbrains.annotations.NotNull Integer resourceId) {
        List<Repository> repositories = repositoryExtMapper
                .selectTaskRepositoryIdsByResourceId(resourceId);
        if (CollectionUtils.isEmpty(repositories)) {
            return null;
        } else {
            return repositories;
        }
    }


    public List<Integer> selectAllSurveillanceRepository() throws DaoException {
        try {
            return repositoryExtMapper.selectAllSurveillanceRepository();
        } catch (Exception e) {
            log.info("e.class:" + e);
            throw new DaoException("selectAllRepository error:{}", e);
        }
    }

    public List<IdAndType> selectAllSurveillanceRepositoryIdAndType(Integer businessType) throws DaoException {
        try {
            return repositoryExtMapper.selectAllSurveillanceRepositoryIdAndType(businessType);
        } catch (Exception e) {
            log.info("e.class:" + e);
            throw new DaoException("selectAllRepositoryIdAndType error:{}", e);
        }
    }


    public Repository selectGlobalNewRepository() {
        return repositoryExtMapper.selectGlobalNewRepository();
    }

    public Repository selectGlobalNewRepositoryByType(){
        return repositoryExtMapper.selectGlobalNewRepositoryByType();
    }

    /**
     * 根据业务类型和资源类型查找没有绑定冷搜算子的抓拍库
     * @param businessType
     * @param resourceType
     * @return
     */
    public List<Repository> selectUnbindColdRetrievalResourceCapture(Integer businessType, Integer resourceType){
        return repositoryExtMapper.selectUnbindColdRetrievalResourceCapture(businessType,resourceType);
    }

    /**
     * 删除所有数据，慎用
     * 仅用于单元测试用例
     */
    public void deleteAll() {
        repositoryExtMapper.deleteAll();
    }


    @Nullable
    public List<RepositorySearchInfo> selectAvailableByRepositoryRecordId(
            List<String> repositoryRecordIds) throws DaoException {
        try {
            return repositoryExtMapper.selectAvailableByRepositoryRecordId(repositoryRecordIds);
        } catch (Exception e) {
            log.error("selectAvailableByRepositoryRecordId Exception:", e);
            throw new DaoException("selectAvailableByRepositoryRecordId error:{}", e);
        }
    }

    @Nullable
    public RepositorySearchInfo selectAvailableByRepositoryId(Integer repositoryId)
            throws DaoException {
        try {
            return repositoryExtMapper.selectAvailableByRepositoryId(repositoryId);
        } catch (Exception e) {
            log.error("selectAvailableByRepositoryId Exception:", e);
            throw new DaoException("selectAvailableByRepositoryId error:{}", e);
        }
    }

    @Nullable
    public RepositorySearchInfo selectMemRepoByRepositoryRecordId(String repositoryRecordId)
            throws DaoException {
        try {
            return repositoryExtMapper.selectMemRepoByRepositoryRecordId(repositoryRecordId);
        } catch (Exception e) {
            log.error("selectMemRepoByRepositoryRecordId Exception:", e);
            throw new DaoException("selectMemRepoByRepositoryRecordId error:{}", e);
        }
    }

    public Integer queryCount(Integer start, Integer limit, Integer type, String name, String key,
                              Integer uid) {
        return repositoryExtMapper.selectCount(start, limit, type, name, key, uid);
    }


    public List<RepositorySearchInfo> query(Integer start, Integer limit, Integer type, String name,
                                            String key, Integer uid) throws DaoException {
        try {
            List<RepositorySearchInfo> repositorySearchInfos = repositoryExtMapper
                    .selectAll(start, limit, type, name, key, uid);
            return repositorySearchInfos;
        } catch (Exception e) {
            log.error("query repositoryInfo from mysql exception : ", e);
            throw new DaoException("query repository mysql exception!");
        }
    }

    public List<RepositorySetInfo> queryFaceSetInfo(List<String> ids, Integer start, Integer limit,
                                                    Integer type, String name, String key, Integer uid) throws DaoException {
        try {
            if (CollectionUtils.isNotEmpty(ids)) {
                List<RepositorySetInfo> repositorySetInfos = repositoryExtMapper
                        .selectFaceSetInfoByIds(ids, uid);
                if (CollectionUtils.isNotEmpty(repositorySetInfos)
                        && repositorySetInfos.size() != ids.size()) {
                    log.error(
                            "query ids size is ({}), but mysql return size is ({}), maybe some repositoryId do not belong uid ({})",
                            ids.size(), repositorySetInfos.size(), uid);
                }
                return repositorySetInfos;
            } else {
                return repositoryExtMapper
                        .selectFaceSetInfo(start - 1, limit, type, name, key, uid);
            }
        } catch (Exception e) {
            log.error("query repositoryInfo from mysql exception : ", e);
            throw new DaoException("query repository mysql exception!");
        }
    }

    @Nullable
    public RepositorySearchInfo selectRepoByRepositoryRecordId(String repositoryRecordId,
                                                               Integer businessType, List<Integer> types, Integer uid) throws DaoException {
        try {
            return repositoryExtMapper
                    .selectRepoByRepositoryRecordId(repositoryRecordId, businessType, types, uid);
        } catch (Exception e) {
            log.error("selectRepoByRepositoryRecordId Exception : ", e);
            throw new DaoException("selectRepoByRepositoryRecordId error:{}", e);
        }
    }

    public List<RepositorySearchInfoUnCount> queryAll(Integer start, Integer limit,
                                                      @Param("repositoryRecordTypes") List<String> repositoryRecordTypes,
                                                      String name, String key, Integer businessType, Integer uid) {
        return repositoryExtMapper
                .selectAllRepositoryByParam(start, limit, repositoryRecordTypes, name, key,
                        businessType, uid);
    }

    public int queryRepositoryReloadCount(List<Integer> types) throws DaoException {
        try {
            return repositoryExtMapper.queryRepositoryReloadCount(types);
        } catch (Exception e) {
            log.error("queryRepositoryReloadCount error: {}", e.getMessage(), e);
            throw new DaoException("queryRepositoryReloadCount error: ", e);
        }
    }

    public List<RepositoryReloadInfo> queryRepositoryReloadInfo(Integer start, Integer limit,
                                                                List<Integer> types) throws DaoException {
        try {
            return repositoryExtMapper.queryRepositoryReloadInfo(start, limit, types);
        } catch (Exception e) {
            log.error("queryRepositoryReloadInfo error: {}", e.getMessage(), e);
            throw new DaoException("queryRepositoryReloadInfo error: ", e);
        }
    }

    /******************************************以下为基于重构的dao****************************************************/

    public Repository selectByRecordId(@org.jetbrains.annotations.NotNull String recordId, Integer uid) throws DaoException {
        try {
            return repositoryExtMapper.selectByRecordId(recordId, uid);
        } catch (Exception e) {
            log.error("selectByRecordId dao error: ", e);
            throw new DaoException("selectByRecordId dao error: ", e);
        }
    }

    public List<AlarmRouteRepInfo> selectAllAlarmRouteRepInfo() throws DaoException {
        try {
            return repositoryExtMapper.selectAllAlarmRouteRepInfo();
        } catch (Exception e) {
            log.error("getAllAlarmRouteRepInfo occur error :{}", e.getMessage(), e);
            throw new DaoException("getAllAlarmRouteRepInfo occur error", e);
        }

    }

}
```

#### 1.1. 创建人像库

#####   1.1.1 时序图

<img src="C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240717095338554.png" alt="image-20240717095338554" style="zoom:100%;" />

##### 

##### 1.1.2 流程图

##### 1.2.3 实现逻辑描述

1. SaaS平台下发修改任务，校验参数，name,memo长度不超过128 

2. 根据repositoryRecordId查询数据库表REPOSITORY记录，如果不存在，返回异常。

3. 判断是否为黑白名单库，且是否修改库名称。

   3.1 是  修改库名称，并请求Excutor同步路由

   3.2 否  修改库信息

4. 返回

##### 1.2.4 代码实现

1. controller 层

```java
/**
     * 修改face库.
     *
     * @param repositoryRecordId 脱敏的repositoryRecordId
     * @param faceSetBean        face库数据传输对象
     * @return 返回成功还是失败.
     * @throws AppException 校验失败时
     */
    @PutMapping("/repository/{repositoryRecordId}")
    @AuthEnable
    public ResponseEntity<Object> update(@PathVariable String repositoryRecordId,
                                         @RequestBody FaceSetBean faceSetBean)
            throws AppException {
        log.info("[PUT /face/repository/repositoryRecordId/{} ，params : {}]", repositoryRecordId,
                new Gson().toJson(faceSetBean));
        faceSetBean.doUpdateRequestVerify();
        ServiceResponse result = faceSetService.update(repositoryRecordId, faceSetBean);
        return ResponseUtil.genResponse(result);
    }
```

2. service层

```java
/**
     * 人像库更新操作.
     * @param repositoryRecordId 人像库脱敏ID.
     * @param faceSetBean 更新人像库信息.
     * @return 成功  失败.
     */
    public ServiceResponse update(String repositoryRecordId, FaceSetBean faceSetBean) {
        Repository repository = new Repository();
        repository.setRepositoryRecordId(repositoryRecordId);
        repository.setMemo(faceSetBean.getMemo());
        repository.setRepositoryName(faceSetBean.getName());

        // 执行
        RepositoryOptRst modifyRst = repositoryCenterService.modify(repository);

        if (!modifyRst.getCommonResponse().getSuccess()) {
            return transRepoOptRstToErrorResponse(modifyRst);
        }
        return create200ResponseWithoutBody();
    }
```

* 具体逻辑由 repositoryCenterService.modify(repository); 执行

```java
/**
     * 未使用缓存，实时查询.
     *
     * @param newRepository 待修改的查询
     * @return RepositoryOptRst
     */
    @Override
    public RepositoryOptRst  modify(Repository newRepository) {
        AuthInfo authInfo = authentication.getCurrentAccount();
        // 先从数据库中找到
        Repository repository = repositoryResourceAllServiceImpl.queryRepositoryByRepositoryRecordId(newRepository.getRepositoryRecordId(), authInfo.getUserId());
		// ....
        RepositoryTemplate commonRepository = new CommonRepository(repositoryResourceAllServiceImpl);
        RepositoryOptRst repositoryOptRst = new RepositoryOptRst();
        repositoryOptRst.setCommonResponse(commonRepository.modify(newRepository, repository)); // 更新
        return repositoryOptRst;
    }
```

* * 再执行 commonRepository.modify(newRepository, repository)

  ```java
  /**
       * 更新人像库信息. 
       * @param newRepository 新人像库信息
       * @return 成功   失败
       */
      public final RestCommonResponse modify(Repository newRepository, Repository oldRepository) {
          try {
              if (null == this.repository) {
                  this.repository = oldRepository;
              }
  
              //库名称是否重复
  			// ....
              //更新状态
              newRepository.setBusinessType(this.repository.getBusinessType());
              newRepository.setState(RepositoryState.ISSUCCESS.getType());
              newRepository.setRepositoryId(this.repository.getRepositoryId());
              boolean update2TaskManager = RepositoryType.BLOCKLIST.value.equals(oldRepository.getRepositoryType()) ||
                              RepositoryType.ALLOWLIST.value.equals(oldRepository.getRepositoryType());
              if (StringUtils.isNotBlank(newRepository.getRepositoryName()) && update2TaskManager &&
                      !this.repository.getRepositoryName().equals(newRepository.getRepositoryName())) {
                  log.info("updateById repository name will also send to taskManager");
                  return repositoryResourceAllServiceImpl.update2TaskManager(newRepository);
              }
              
              if (repositoryResourceAllServiceImpl.update(newRepository)) {
                  return new RestCommonResponse(true);
              }
          } 
      }
  ```

  * * repositoryResourceAllServiceImpl.update(newRepository) 去执行dao中的mapper

  ```java
  public boolean update(Repository repository) throws Exception {
          if (null == repository) {
              return true;
          }
          long updateTime = DateUtils.getUtcCurrentTimeMillis();
          repository.setUpdatetime(updateTime);
          log.info("modify repo info : {}", JSONObject.toJSONString(repository));
          repositoryExtMapper.updateRepoByRepositoryId(repository);
          return true;
      }
  ```

  ```xml
  <update id="updateRepoByRepositoryId"
              parameterType="com.dahuatech.cvengine.perception.database.core.model.Repository">
          update REPOSITORY
          <set>
              <if test="repository.updatetime != null">
                  REPOSITORY.UPDATETIME = #{repository.updatetime,jdbcType=BIGINT},
              </if>
              <if test="repository.repositoryName != null and repository.repositoryName != ''">
                  REPOSITORY_NAME = #{repository.repositoryName,jdbcType=VARCHAR},
              </if>
              <if test="repository.memo != null">
                  MEMO = #{repository.memo,jdbcType=VARCHAR},
              </if>
              <if test="repository.lifeCycle != null">
                  LIFE_CYCLE = #{repository.lifeCycle,jdbcType=BIGINT},
              </if>
              REPOSITORY.STATE =
              CASE
              WHEN (REPOSITORY.STATE IS NULL OR REPOSITORY.STATE > 1) THEN #{repository.state}
              ELSE REPOSITORY.STATE
              END
              ,
              OPERATION_VERSION =
              CASE
              WHEN REPOSITORY.OPERATION_VERSION is null THEN 1
              ELSE REPOSITORY.OPERATION_VERSION + 1
              END
          </set>
          where REPOSITORY_ID = #{repository.repositoryId}
      </update>
  ```

  修改黑白名单库，修改库名称，并请求Excutor同步路由

  ```java
  boolean update2TaskManager = RepositoryType.BLOCKLIST.value.equals(oldRepository.getRepositoryType()) ||
                              RepositoryType.ALLOWLIST.value.equals(oldRepository.getRepositoryType());
              if (StringUtils.isNotBlank(newRepository.getRepositoryName()) && update2TaskManager &&
                      !this.repository.getRepositoryName().equals(newRepository.getRepositoryName())) {
                  log.info("updateById repository name will also send to taskManager");
                  return repositoryResourceAllServiceImpl.update2TaskManager(newRepository);
              }
  ```

  * 关注 repositoryResourceAllServiceImpl.update2TaskManager(newRepository); 

  ```java
   @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)
      public RestCommonResponse update2TaskManager(Repository newRepository) throws Exception {
          update(newRepository);
          //发送给taskManager
          updateNameToTaskManager(newRepository);
          return new RestCommonResponse(true);
      }
  ```

  * 关注 updateNameToTaskManager(newRepository);

  ```java
  private void updateNameToTaskManager(Repository repository) {
          AuthInfo currentAccount = authentication.getCurrentAccount();
          RepositoryInfo repositoryInfo = RepositoryInfo.newBuilder()
                  .setId(String.valueOf(repository.getRepositoryId()))
                  .setName(repository.getRepositoryName())
                  .setRecordId(repository.getRepositoryRecordId())
                  .setBusinessType(repository.getBusinessType())
                  .build();
          UpdateRepositoryRequest updateRepositoryRequest = UpdateRepositoryRequest.newBuilder()
                  .setReqHeader(HeaderUtils.buildCommonRequest())
                  .setRepositoryInfo(repositoryInfo)
                  .setUid(String.valueOf(currentAccount.getUserId()))
                  .build();
          CommonResponse commonResponse = pushService.updateRepositoryInfo(updateRepositoryRequest);
  }
  ```

  推送库信息给算子. public interface PushService

  ```java
  // RpcPushServiceImpl.java 
  @Override
  public CommonResponse updateRepositoryInfo(UpdateRepositoryRequest request) {
      // ...
      commonResponse = executorServiceClient.updateRepositoryInfo(updateRepositoryRequest);
      ExecutorService.switchReturnInfo(commonResponse);
  }
  ```

  再看 executorServiceClient.updateRepositoryInfo(）

  ```java
  @Override
  public CommonResponse updateRepositoryInfo(UpdateRepositoryRequest request) {
      List<ServiceNode> serviceNodes = executorServerManager.getAllExInfos();
  
      List<AbstractSubBroadcastTask<CommonResponse>> updateRepositoryTasks = new ArrayList<>();
      for (ServiceNode serviceNode : serviceNodes) {
          /**
               *  UpdateRepositoryInfoTask(ServiceNode serviceNode, UpdateRepositoryRequest updateRepositoryRequest) {
               *             this.serviceNode = serviceNode;
               *             this.updateRepositoryRequest = updateRepositoryRequest;
               *         }
               */
          UpdateRepositoryInfoTask updateRepositoryTask = new UpdateRepositoryInfoTask(serviceNode, request);
          updateRepositoryTasks.add(updateRepositoryTask);
      }
  
      CommonResponse commonResponse = RpcUtils
          .buildCommonResponse(RpcReturnCode.unavailable.getReturnCode());
      return submitBroadcastTaskList(updateRepositoryTasks, commonResponse);
  }
  
  ```

UpdateRepositoryInfoTask 实现了AbstractSubBroadcastTask, submit后执行remoteProcedureCall()方法

```java
// UpdateRepositoryInfoTask 实现了AbstractSubBroadcastTask
abstract static protected class AbstractSubBroadcastTask<V> implements Callable<V> {
        private CountDownLatch countDownLatch;

        void setCountDownLatch(CountDownLatch countDownLatch) {
            this.countDownLatch = countDownLatch;
        }

        @Override
        public V call() {
            try {
                return remoteProcedureCall();
            } finally {
                MDCWrapper.clear();
                countDownLatch.countDown();
            }
        }

        /**
         * RPC调用
         * @return RPC 响应
         */
        protected abstract V remoteProcedureCall();
    }
```



```java
@Override
protected CommonResponse remoteProcedureCall() {
    MDCWrapper.putTraceId(updateRepositoryRequest.getReqHeader().getRequestId());
    ExecutorServiceGrpc.ExecutorServiceBlockingStub stub = buildBlockingStub(serviceNode);
    RpcContext.getContext().set(Constant.SERVICE_NODE, serviceNode);
    return stub.updateRepositoryInfo(updateRepositoryRequest);
}
```

#### 3 删除人像库

##### 3.1 时序图

![image-20240718085054316](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718085054316.png)

##### 3.2 关键路径流程图

![image-20240718085841349](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718085841349.png)

##### 3.3 实现逻辑描述

1. SaaS平台下发删除任务，校验参数RecordId不能为空。

2. 查询REPOSITORY表中记录是否存在RecordId是否存在。

3. 存在该人像库，则判断该人像库是否被 布控任务（SURVEILLANCE表）、通道分析（CHANNEL_ANALYSIS表）、NVN任务（NVN_JOB表）使用。

4. 如果人像库在使用，抛出异常，正在使用，不可删除，不在使用跟新REPOSITORY.STATE、REPOSITORY_RESOURCE. OPERATION_STATE状态-2

5. 删除内存缓存，库id信息缓存，库资源关系缓存。

6. 返回成功

7. 后台线程执行清理动作



涉及到两个数据表 【Repository】和【Repository_Resource】

##### 3.4 业务逻辑实现

1. controller层接口

```java
/**
     * 删除face库.
     * @param repositoryRecordId 脱敏的repositoryRecordId
     * @return 返回成功 失败
     */
@AuthEnable
@RequestMapping(value = {"/repository/{repositoryRecordId}"}, method = {RequestMethod.DELETE})
public ResponseEntity<Object> delete(@PathVariable String repositoryRecordId) {
    ServiceResponse result = faceSetService.delete(repositoryRecordId);
    return ResponseUtil.genResponse(result);
}
```

2. service层服务

```java
/**
     * 删除人像库信息.
     * @param repositoryRecordId 人像库脱敏ID.
     * @return 成功  失败.
     */
public ServiceResponse delete(String repositoryRecordId) {

    RepositoryOptRst deleteRst = repositoryCenterService.delete(repositoryRecordId);

    // 聚类业务，直接发mq 删除库
    saveRecordService.deleteRepository(repositoryRecordId);

    if (!deleteRst.getCommonResponse().getSuccess()) {
        Repository repository = new Repository();
        repository.setRepositoryRecordId(repositoryRecordId);
        return transRepoOptRstToErrorResponse(deleteRst);
    }

    //从内存中删除库信息,前端后端均调用一遍，以免区分前后端
    try {
        Repository repository = deleteRst.getRepository();
        if (null != repository) {
            defaultRetrievalResourceCacheManage.removeRepositoryCache(repositoryRecordId, repository.getRepositoryId(), repository.getUid());
        }
    } catch (Exception e) {
        log.error("del repository info from memory exception : ", e);
    }

    return create200ResponseWithoutBody();
}
```

 分成多个步骤：

1. 修改Repository表中的状态值（state）（-2、-9）以及operation_version(每次+1)

抓拍库只需要删除表记录，跟人像库一系列整库删除流程不一样，抓拍库修改为(-9)，其他库修改为(-2); 修改 `REPOSITORY_RESOURCE` 表中的 `OPERATION_STATE = -2`

> * 删表`RepositoryOptRst deleteRst = repositoryCenterService.delete(repositoryRecordId);`
>
> * * 
>
>   ```java
>    @Override
>       public RepositoryOptRst delete(String repositoryRecordId) {
>         // 重点 
>       repositoryOptRst.setCommonResponse(commonRepository.delete(repositoryRecordId, authInfo.getUserId(), null));
>       }
>   ```
>
> * `commonRepository.delete(repositoryRecordId, authInfo.getUserId(), null)`
>
> * * ```java
>     /**
>      * 根据脱敏ID删除人像库.
>      * @param repositoryRecordId 人像库脱敏ID.
>      * @return 成功  失败
>      */
>     public final RestCommonResponse delete(String repositoryRecordId, int uid,Integer dataSource) {
>         try {
>             if (null == repository) {
>                 repository = queryRepositoryByRepositoryRecordId(repositoryRecordId, uid);
>             }
>     // ...
>          //判断该人像库是否被使用,正在使用不能删除
>         
>          //更新状态
>          Repository repositoryDel = new Repository();
>          //抓拍库只需要删除表记录，跟人像库一系列整库删除流程不一样
>       repositoryDel.setState(repository.getRepositoryType().equals(RepositoryType.CAPTURE.value) ? Step.MYSQL_REPOSITORY.getStep() : RepositoryState.TOBECLEAN.getType());
>          
>          repositoryDel.setRepositoryId(repository.getRepositoryId());       		 repositoryDel.setRepositoryRecordId(repository.getRepositoryRecordId());
>          repositoryDel.setBusinessType(repository.getBusinessType());
>          Boolean isDelete = repositoryResourceAllServiceImpl.delete(repositoryDel, dataSource);   
>         }
>     ```
>
> * `Boolean isDelete = repositoryResourceAllServiceImpl.delete(repositoryDel, dataSource);`
>
> * * ```java
>     @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)
>     public boolean delete(Repository repository, Integer... dataSource) {
>         // 执行删除
>         if (repositoryExtMapper.updateDelRepoByRepositoryId(repository) < 0) {
>             throw new RuntimeException("delete repository info exception!");
>         }
>         delRepoToTaskManager(Arrays.asList(repository), repository.getBusinessType(), dataSource);
>         return true;
>         }
>     ```
>
> * `repositoryExtMapper.updateDelRepoByRepositoryId(repository)`
>
> * * ```xml
>     <update id="updateDelRepoByRepositoryId"
>            parameterType="com.dahuatech.cvengine.perception.database.core.model.Repository">
>         update REPOSITORY
>         <set>
>             <if test="repository.updatetime != null">
>                 REPOSITORY.UPDATETIME = #{repository.updatetime,jdbcType=BIGINT},
>             </if>
>             REPOSITORY.STATE = #{repository.state}
>                 ,
>                 OPERATION_VERSION =
>                 CASE
>                 WHEN REPOSITORY.OPERATION_VERSION is null THEN 1
>                 ELSE REPOSITORY.OPERATION_VERSION + 1
>                 END
>         </set>
>         where REPOSITORY_ID = #{repository.repositoryId}
>     </update>
>     ```
>
> * 还要执行`delRepoToTaskManager(Arrays.asList(repository), repository.getBusinessType(), dataSource);` 
>
> * * ```java
>     @Override
>         public void delRepositoryResource(DelRepResourceRequest request) throws DaoException {
>             if (StringUtils.isBlank(request.getUid()) || CollectionUtils.isEmpty(request.getRepositoryIds())) {
>                 log.error("DelRepResourceRequest param is error,return");
>                 throw new BusinessException(VCS_MISSING_PARAM);
>             }
>             List<IRepositoryResourceHandle> handles = getBusinessTypeHandles(request.getBusinessType(), request.getRepositoryType(), request.getDataSource());
>             if (CollectionUtils.isEmpty(handles)) {
>                 log.error("no IRepositoryResourceHandle impl");
>                 throw new BusinessException(VCS_PARAM_ERROR);
>             }
>             for (IRepositoryResourceHandle handle : handles) {
>                 // 重点
>                 handle.deleteRepositoryResourceInfo(request);
>             }
>         }
>     ```
>
> * `handle.deleteRepositoryResourceInfo(request);`
>
> * * ```java
>     @Override
>         public void deleteRepositoryResourceInfo(DelRepResourceRequest request) throws DaoException {
>             String uid = request.getUid();
>             List<Integer> repositoryIds = Lists.newArrayList();
>             request.getRepositoryIds().forEach(repoId -> repositoryIds.add(Integer.valueOf(repoId)));
>             // 逻辑删除数据库
>             deleteToDb(repositoryIds);
>             // 根据库删除库资源缓存缓存
>             removeRepositoryCache(uid, repositoryIds);
>         }
>     ```
>
> * `// 逻辑删除数据库
>           deleteToDb(repositoryIds);`
>
> * * ```java
>     /**
>          * 逻辑删除数据库
>          *
>          * @param repositoryIds
>          */
>     protected void deleteToDb(List<Integer> repositoryIds) throws DaoException {
>         repositoryResourceDao.updateStateByRepositoryIds(repositoryIds);
>     }
>     ```
>
>   * ```jav
>     public int updateStateByRepositoryIds(List<Integer> repositoryIds) throws DaoException {
>         try {
>     
>         return repositoryResourceExtMapper.updateStateByRepositoryIds(repositoryIds);
>         } catch (Exception e) {
>         log.error("update statebyRepositoryId failed:{}", e.getMessage());
>         throw new DaoException("update statebyRepositoryId failed");
>         }
>     }
>     ```
>
> * `repositoryResourceExtMapper.updateStateByRepositoryIds(repositoryIds);`
>
> * * 修改 `REPOSITORY_RESOURCE` 表中的 `OPERATION_STATE = -2`
>
>     ```java
>     <update id="updateStateByRepositoryIds" parameterType="java.util.List">
>         update REPOSITORY_RESOURCE
>         SET OPERATION_STATE = -2
>         where REPOSITORY_ID in
>         <foreach collection="list" item="repositoryId" open="(" separator="," close=")">
>           #{repositoryId,jdbcType=INTEGER}
>         </foreach>
>       </update>
>     ```
>
> * 还需要执行 `// 根据库删除库资源缓存缓存
>           removeRepositoryCache(uid, repositoryIds);`
>
> * * ```java
>     /**
>      * 删除缓存
>      * @param repositoryIds
>      * @param uid
>      */
>     protected void removeRepositoryCache(String uid, List<Integer> repositoryIds) {
>         repositoryIds.forEach(repositoryId -> {
>             Map<String, Set<ShardToResource>> shardToResourceMap = map.get(uid);
>             if (MapUtils.isNotEmpty(shardToResourceMap)) {
>                 shardToResourceMap.remove(repositoryId.toString());
>             }
>         });
>     }
>     ```

2.  聚类业务，直接发mq 删除库

> * ```
>   // 聚类业务，直接发mq 删除库
>   saveRecordService.deleteRepository(repositoryRecordId);
>   ```
>
> * * 
>
>   ```java
>   //行业一体机，删除库
>       public void deleteRepository(String repositoryRecordId) {
>           FaceMember2Cluster faceMember2Cluster = new FaceMember2Cluster();
>           faceMember2Cluster.setEvent(MEMBER_EVENT);
>           faceMember2Cluster.setOperation(MemberOperationEnum.DELETE_MEMBER_REPOSITORY.getCode());
>           faceMember2Cluster.setRepositoryId(repositoryRecordId);
>           log.info("send delete repository message the repositoryRecordId is {}",repositoryRecordId);
>           // 重点
>           sendByMq(Collections.singletonList(faceMember2Cluster));
>       }
>   ```
>
> * `sendByMq(Collections.singletonList(faceMember2Cluster));`
>
> * * ```java
>     public SaveRecordResponse sendByMq(List<FaceMember2Cluster> faceMember) {
>             log.info("send message into cluster db ,size is {}",faceMember.size());
>             Integer userId = authentication.getCurrentAccount().getUserId();
>             String exchange = commonProperties.getFaceMemberClusterExchange();
>             String routeKey = String.join("",commonProperties.getFaceMemberClusterRouteKey(),userId.toString());
>             log.info("send FaceMember2Cluster message to exchange:{} , routeKey:{}",exchange,routeKey);
>             HashMap<String, Boolean> sendResult = new HashMap<>();
>             faceMember.forEach(item ->{
>                 boolean send = rabbitMqSender.send(JSONObject.toJSONString(item), exchange, routeKey);
>                 sendResult.put(item.getMemberId(),send);
>             });
>             List<String> failedMemberIdList = sendResult.entrySet().stream().filter(entry -> entry.getValue().equals(false)).map(Map.Entry::getKey).collect(Collectors.toList());
>             log.info("send message into cluster db success size {}",faceMember.size() - failedMemberIdList.size());
>             if (!CollectionUtils.isEmpty(failedMemberIdList) && failedMemberIdList.size() == faceMember.size()){
>                 return new SaveRecordResponse(true, new ErrorCode(ErrorEnum.VCS_MQ_ERROR.getError_code(), ErrorEnum.VCS_MQ_ERROR.getError_desc(), ErrorEnum.VCS_MQ_ERROR.getHttpStatus()), failedMemberIdList);
>             }
>             return new SaveRecordResponse(false, new ErrorCode(ErrorEnum.VCS_MQ_ERROR.getError_code(), ErrorEnum.VCS_MQ_ERROR.getError_desc(), ErrorEnum.VCS_MQ_ERROR.getHttpStatus()), failedMemberIdList);
>         }
>     ```
>
> * `boolean send = rabbitMqSender.send(JSONObject.toJSONString(item), exchange, routeKey);`
>
> * * ```java
>     public boolean send(String message, String exchange, String routingKey) {
>         long start = System.currentTimeMillis();
>         try {
>             this.rabbitTemplate.convertAndSend(exchange, routingKey, message);
>             long end = System.currentTimeMillis();
>             long takeTime = end - start;
>             if (takeTime > 20) {
>                 log.warn("send to mq too slow, takeTime is {}", takeTime);
>             }
>             return true;
>         } catch (Exception e) {
>             reconnectionAction();
>             log.error("send message error: " + e);
>             return false;
>         }
>     }
>     ```
>
>   * 为什么发送到mq就可以删除？

3.  从内存中删除库信息,前端后端均调用一遍，以免区分前后端

> * `defaultRetrievalResourceCacheManage.removeRepositoryCache(repositoryRecordId, repository.getRepositoryId(), repository.getUid());`
>
> * * ```java
>     @Override
>     public void removeRepositoryCache(String repositoryRecordId, Integer repositoryId,
>                                       Integer uid) {
>         // 重点
>         retrievalResourceCache.removeRepositoryCache(repositoryRecordId, repositoryId, uid);
>     }
>     ```
>
> * `retrievalResourceCache.removeRepositoryCache(repositoryRecordId, repositoryId, uid);`
>
> * * 从内存中删除对应的信息记录
>
>     ```java
>     /**
>          * 删除库使用（布控库、静态库、抓拍库）
>          *
>          * @param repositoryRecordId
>          * @param uid                鉴权用户id
>          */
>     public void removeRepositoryCache(String repositoryRecordId, Integer repositoryId, Integer uid) {
>         String repoStr = String.valueOf(repositoryId);
>         recordRepositoryIdMap.remove(repositoryRecordId);
>         repositoryTypeMap.remove(repoStr);
>         if (userRepositoryMap.containsKey(uid)) {
>             userRepositoryMap.get(uid).remove(repoStr);
>         }
>     }
>     ```

#### 4. 查询人像库

##### 4.1 时序图

![image-20240718105301037](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718105301037.png)

##### 4.2 关键路径流程图

![image-20240718105336712](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718105336712.png)

##### 4.3 实现逻辑描述

1. SaaS平台下发查询请求，校验参数，分页参数校验；组装查询参数name/key模糊查询。

2. 判断库成员存储位置

   2.1 云库 查询云库个人像库ID对应成员人数。

   2.2  mysql 查询MEMBER, REPOSITORY 表统计人像库ID对应库成员人数。

3. 返回封结果

##### 4.4 业务逻辑实现

1. controller层接口

```java
/**
     * 分页查询人像库信息.
     * @param start 从第几个结果开始返回,最小值为1，不填默认为1
     * @param limit 返回至多多少结果，最大值为1024，不填默认为512
     * @param type  人像库类型
     * @param name  人像库名称，支持模糊查询，即支持前向匹配、后向匹配、中间匹配
     * @param key   人像库名称或者描述的模糊查询，支持前向匹配、后向匹配、中间匹配（人像大数据平台使用）；当name不为空时，以name为主
     * @return 人像库分页信息
     * @throws AppException 检验失败时
     */
    @GetMapping("/repository")
    @AuthEnable
    public ResponseEntity<Object> query(
            @RequestParam(value = "start", defaultValue = "1") Integer start,
            @RequestParam(value = "limit", defaultValue = "512") Integer limit,
            @RequestParam(value = "type", required = false) Integer type,
            @RequestParam(value = "name", required = false) String name,
            @RequestParam(value = "key", required = false) String key) throws AppException {
        // ...
        result = queryFaceSetService.query(start, limit, type, name, key);
        return ResponseUtil.genResponse(result);
    }
```

2. service层

```java
/**
     * 根据库类型、名称分页查询库信息，支持库名称的模糊查询。(注：抓拍库不返回,只返回0  1  2 库类型).
     *
     * @param start 起始
     * @param limit 最多
     * @param type  库类型
     * @param name  库名称
     * @param key   关键字（身份证或者名字）
     * @return 满足条件库列表.
     * @throws AppException 异常返回.
     */
public ServiceResponse query(Integer start, Integer limit, Integer type,
                             String name, String key) throws AppException {
    // 校验分页参数

    try {
        // 参数进行转义
        name = decodeQueryParam(name);
        key = decodeQueryParam(key);
        JSONObject result = repositoryService.query(start, limit, type, name, key);
        return ServiceResponse.build(HttpStatus.OK, result, true);
    } catch (Exception e) {
        log.error("query mysql error", e);
        return ServiceResponse.transRepoOptRstToErrorResponse(e,
                                                              "query repository failed.");
    }
}
```

3. serviceImpl具体实现

```java
/*
     * 查看人像库
     */
@Override
public JSONObject query(Integer start, Integer limit, Integer type, String name, String key)
    throws Exception {
    // ...
    // 查询满足条件的记录总条数
    Integer totalCount = repositoryDao.queryCount(start - 1, limit, type,
                                                  name, key, authInfo.getUserId());

    // 分页查询
    List<RepositorySearchInfo> repositoryList = repositoryDao
        .query(start - 1, limit, type, name, key, authInfo.getUserId());
    // 当不存在库时 直接返回查询结果
    if (CollectionUtils.isEmpty(repositoryList)) {
        result.put("totalCount", totalCount);
        result.put("results", new ArrayList<RepositorySearchInfo>());
        return result;
    }

    // 统计各个库下面对应的member个数
    List<String> repositoryRecordIds = repositoryList.stream()
        .collect(Collectors.mapping(
            RepositorySearchInfo::getRepositoryRecordId,
            Collectors.toList()));

    // 根据库ID查询库成员个数信息
    Map<String, Integer> repoMemberCount = queryRepositoryMemberCount(repositoryRecordIds);

    // 将库对应的库成员个数信息封装到结果中
    for (RepositorySearchInfo info : repositoryList) {
        int count = 0;
        if (repoMemberCount.get(info.getRepositoryRecordId()) != null) {
            count = repoMemberCount.get(info.getRepositoryRecordId())
                .intValue();
        }
        info.setTotalPictureCount(count); // 库中图片的数目
        info.setFaceImageCount(count); // 库中face数量
    }

    result.put("results", repositoryList);
    result.put("totalCount", totalCount);
    return result;
}
```

* 先查询记录总条数

   `Integer totalCount = repositoryDao.queryCount(start - 1, limit, type,
                                                    name, key, authInfo.getUserId());`

  > ```java
  > public Integer queryCount(Integer start, Integer limit, Integer type, String name, String key,
  >                               Integer uid) {
  >         return repositoryExtMapper.selectCount(start, limit, type, name, key, uid);
  >     }
  > ```
  >
  > * mapper.xml 
  >
  > * ```xml
  >   <select id="selectCount" resultType="java.lang.Integer">
  >       SELECT count(1) FROM REPOSITORY WHERE STATE >= 0 AND REPOSITORY_TYPE IN (0, 1, 2)
  >       <if test="type !=null">
  >           AND REPOSITORY_TYPE = #{type,jdbcType=INTEGER}
  >       </if>
  >       <if test="name !=null">
  >           AND REPOSITORY_NAME LIKE #{name,jdbcType=VARCHAR}
  >       </if>
  >       <if test="name ==null">
  >           <if test="key !=null">
  >               AND (REPOSITORY_NAME LIKE #{key,jdbcType=VARCHAR}
  >               OR MEMO LIKE #{key,jdbcType=VARCHAR})
  >           </if>
  >       </if>
  >       <if test="uid !=null">
  >           AND UID = #{uid,jdbcType=INTEGER}
  >       </if>
  >       AND BUSINESS_TYPE = 0
  >   </select>
  >   ```

* 再将记录全部取出来 

```
// 分页查询
List<RepositorySearchInfo> repositoryList = repositoryDao
        .query(start - 1, limit, type, name, key, authInfo.getUserId());
```

> mapper.xml
>
> ```xml
> <select id="selectAll" resultMap="RepositoryResultMap">
>         select REPOSITORY_ID,REPOSITORY_RECORD_ID,REPOSITORY_NAME,REPOSITORY_TYPE,MEMO,CREATETIME
>         from REPOSITORY
>         where STATE >= 0 and REPOSITORY_TYPE IN (0, 1, 2)
>         <if test="type !=null">
>             AND
>             REPOSITORY_TYPE = #{type,jdbcType=INTEGER}
>         </if>
>         <if test="name !=null">
>             AND
>             REPOSITORY_NAME LIKE #{name,jdbcType=VARCHAR}
>         </if>
>         <if test="name ==null">
>             <if test="key !=null">
>                 AND
>                 (REPOSITORY_NAME LIKE #{key,jdbcType=VARCHAR}
>                 OR
>                 MEMO LIKE #{key,jdbcType=VARCHAR})
>             </if>
>         </if>
>         <if test="uid !=null">
>             AND UID = #{uid,jdbcType=INTEGER}
>         </if>
>         AND BUSINESS_TYPE = 0
>         LIMIT #{start,jdbcType=INTEGER}, #{limit,jdbcType=INTEGER}
>     </select>
> ```

* ```
  统计各个库下面对应的member个数 将所有的Id组成一个List列表;
  根据库ID查询库成员个数信息
  ```

```java
List<String> repositoryRecordIds = repositoryList.stream()
                .collect(Collectors.mapping(
                        RepositorySearchInfo::getRepositoryRecordId,
                        Collectors.toList()));
```

`Map<String, Integer> repoMemberCount = queryRepositoryMemberCount(repositoryRecordIds);`

> ```java
> /**
>      * 根据库ID列表查询库ID对应的库成员个数
>      *
>      * param isMysql       20230508 删除数据库判断      判断从数据库查询还是从云数据库查询库成员个数
>      * @param repositoryRecordIds 待查询库成员个数对应的库ID列表
>      */
> private Map<String, Integer> queryRepositoryMemberCount(
>     List<String> repositoryRecordIds)
>     throws Exception {
>     List<QueryAggregate> repoMembers = null;
>     // 判断库成员查询是否查当前数据库
>     repoMembers = queryDseMemberCount(repositoryRecordIds);
> 
> 
>     // 将查询到的库对应的库成员转换为map
>     if (CollectionUtils.isNotEmpty(repoMembers)) {
>         return repoMembers.stream()
>             .filter(p -> StringUtils.isNotBlank(p.getRepositoryId()))
>             .collect(Collectors.toMap(QueryAggregate::getRepositoryId,
>                                       QueryAggregate::getCount));
>     }
> 
>     return new HashMap<String, Integer>();
> }
> ```
>
> * `// 判断库成员查询是否查当前数据库
>       repoMembers = queryDseMemberCount(repositoryRecordIds);`
>
> * * ```java
>     /**
>          * 根据库ID列表从云数据库查询库成员个数
>          *
>          * @param repositoryRecordIds 库ID列表
>          */
>     private List<QueryAggregate> queryDseMemberCount(
>         List<String> repositoryRecordIds) throws AppException {
>         
>         // 组装调用云数据库接口查询参数
>         CaptureQueryParam captureQueryParam = makeQueryMemberAggParam(
>             repositoryRecordIds);
>         
>         int limit = repositoryRecordIds.size();
>         int start = 1; // 一次性查询出当前页所有库ID包含的成员个数
>         try {
>             JerseyResponse queryMemberAggregate = dseService
>                 .queryMemberAggregate(captureQueryParam,
>                                       authInfo.getAccessKeyId(),
>                                       authInfo.getSecretAccessKey(), start,
>                                       limit);
>                 // 当接口查询成功时
>                 QueryAggregateResult queryAggregateResult = new Gson().fromJson(
>                     (String) queryMemberAggregate.getResult(),
>                     QueryAggregateResult.class);
>                 if (queryAggregateResult != null
>                     && queryAggregateResult.getResult() != null) {
>                     return queryAggregateResult.getResult();
>                 } 
>             }
>         }
>         return null;
>     }
>     ```
>
>   * 重点在 
>
>     ```
>     JerseyResponse queryMemberAggregate = dseService
>             .queryMemberAggregate(captureQueryParam,
>                     authInfo.getAccessKeyId(),
>                     authInfo.getSecretAccessKey(), start,
>                     limit);
>     ```
>
>     * ```java
>       @Override
>       public JerseyResponse queryMemberAggregate(CaptureQueryParam captureQueryParam, String ak,
>                                                  String sk, Integer start, Integer limit) {
>           if (captureQueryParam == null) {
>               return null;
>           }
>       
>           String uri = "/clouddb/dbs/face/member/agg?start=" + start + "&limit=" + limit;
>           String requestUrl = dseServiceUrl + uri;
>           // 
>           Map<String, String> headers = CommonUtils.createAuthorization(POST.name(), uri, sk, ak);
>           return JerseyResponse
>               .of(restTemplateUtil.exchange(requestUrl, POST, headers, captureQueryParam));
>       }
>       ```
>
>      根据ak、sk以及请求的信息组成请求头;向云数据库发起查询请求；请求成功后将查询结果包装到JerseyResponse中。
>
> 得到每个库id及其对应的记录个数

* 最后将库ID和其对应的个数信息封装到结果中。

```java
/**
         * public class RepositorySearchInfo {
         *     @JsonIgnore
         *     private String id;
         *     @JsonProperty("id")
         *     private String repositoryRecordId;
         *     private String name;
         *     private int type;
         *     private String memo;
         *     private long createTime;
         *     private String creator;
         *     private int totalPictureCount;
         *     private int faceImageCount;
         *     private int failedPictureCount;
         *     @JsonIgnore
         *     private Integer totalCount;
         *     @JsonIgnore
         *     private Integer resourceId;
         * }
         */
// 将库对应的库成员个数信息封装到结果中
for (RepositorySearchInfo info : repositoryList) {
    int count = 0;
    if (repoMemberCount.get(info.getRepositoryRecordId()) != null) {
        count = repoMemberCount.get(info.getRepositoryRecordId())
            .intValue();
    }
    info.setTotalPictureCount(count); // 库中图片的数目
    info.setFaceImageCount(count); // 库中face数量
}

result.put("results", repositoryList);
result.put("totalCount", totalCount);
```

返回的结果是一个JSONObject，一项是查出来的数据表Repository中的每一条记录，将其对应的云数据库中的图片数目和face数目存入；另一项是Repository数据表中的记录总条数。

> 个人理解：Repository存的是各种类型库的信息（如静态库对应的id这些基本信息），但重要敏感的数据（如人脸图像）都是存到云端数据库，所以只查询Repository是无法获取这些敏感数据。查询的时候先查询Repository每个库的ID等信息，再用这些信息去查询云端数据库。
>
> 这个查询人像库的接口是获取每个库对应的记录数量。



#### 5. 查看单个人像库

##### 5.1 时序图

![image-20240718150218928](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718150218928.png)

##### 5.2 关键路径流程图

![image-20240718150504778](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718150504778.png)

##### 5.3 实现逻辑描述

1. SaaS平台下发查询请求，校验参数，

2. 根据REPOSITORY_RECORD_ID 查询库信息，如果不存在，抛出异常

3. 判断库成员存储位置、

   3.1云库 查询云库个人像库ID对应成员人数。

   3.2 mysql 查询MEMBER, REPOSITORY 表统计人像库ID对应库成员人数。

4. 返回结果

##### 5.4 业务逻辑实现

1. controller层接口

```java
/**
     * 查询单个人像库信息.
     * @param repositoryRecordId 脱敏的repositoryRecordId
     * @return 该id对应的单个人像库信息
     */
@GetMapping("/repository/{repositoryRecordId}")
@AuthEnable
public ResponseEntity<Object> getInfo(@PathVariable String repositoryRecordId,
                                      @RequestParam(value = "showCounts", required = false) Boolean showCounts) {
    if (showCounts == null) {
        showCounts = true;
    }
    ServiceResponse result = queryFaceSetService.getByRepositoryId(repositoryRecordId, showCounts);
    return ResponseUtil.genResponse(result);
}
```

2. service层

```java
/**
     * 查询单个人像库.
     *
     * @param repositoryRecordId 脱敏ID
     * @param showCounts         是否展示成员个数.
     * @return 库信息列表
     */
public ServiceResponse getByRepositoryId(String repositoryRecordId, Boolean showCounts) {
    try {
        // 只允许查询黑白名单及其静态库(即对应的 0,1,2)
		// 重点
        RepositorySearchInfo result = repositoryService
            .getByRepositoryRecordId(repositoryRecordId,
                                     BusinessType.FACE.getCode(), types, showCounts);
}
```

3. 具体查询方法  `repositoryService.getByRepositoryRecordId()`

```java
/**
     * 通过库ID查询单人像库信息
     * @param repositoryRecordId 库ID
     * @param businessType       业务类型
     * @param showCounts         是否查询库成员个数
     */
@Override
public RepositorySearchInfo getByRepositoryRecordId(
    String repositoryRecordId, Integer businessType, List<Integer> types, Boolean showCounts)
    throws Exception {
   
    // 根据请求库ID查询库信息
    RepositorySearchInfo result = repositoryDao
        .selectRepoByRepositoryRecordId(repositoryRecordId,
                                        businessType, types, authInfo.getUserId());
    // 判断库是否存在
    // 当需要统计库成员个数时
   
    // 从云数据库查询，和查询人像库逻辑相同

    return result;
}
```

这里执行mapper`repositoryDao.selectRepoByRepositoryRecordId()`

```java
@Nullable
public RepositorySearchInfo selectRepoByRepositoryRecordId(String repositoryRecordId,
                                                           Integer businessType, List<Integer> types, Integer uid) throws DaoException {
    try {
        return repositoryExtMapper
            .selectRepoByRepositoryRecordId(repositoryRecordId, businessType, types, uid);
    } 
}
```

mapper.xml

```xml
<select id="selectRepoByRepositoryRecordId" resultMap="RepositoryResultMap">
        select REPOSITORY_ID,
        REPOSITORY_RECORD_ID,
        REPOSITORY_NAME,
        REPOSITORY_TYPE,
        MEMO,
        CREATETIME
        from REPOSITORY
        where STATE >= 0
        <if test="businessType !=null">
            AND
            BUSINESS_TYPE= #{businessType, jdbcType=INTEGER}
        </if>
        <if test="types !=null and types.size() != 0">
            AND REPOSITORY_TYPE in
            <foreach collection="types" item="type" open="(" separator=","
                     close=")">
                #{type,jdbcType=INTEGER}
            </foreach>
        </if>
        <if test="uid !=null">
            AND
            UID= #{uid, jdbcType=INTEGER}
        </if>
        AND REPOSITORY_RECORD_ID = #{repositoryRecordId,jdbcType=VARCHAR} limit 0,1
    </select>
```

返回的是一个 RepositorySearchInfo，需要需要统计库成员个数时，将从云端数据库查询到的数量信息注入

```
result.setTotalPictureCount(count); // 库中图片的数目
result.setFaceImageCount(count); // 库中face数量
```

#### 6. 查看库信息（只看0，1，2库）

##### 6.1 时序图

![image-20240718155309267](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718155309267.png)

##### 6.2 关键路径流程图

![image-20240718155412373](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718155412373.png)

##### 6.3 实现逻辑描述

1. SaaS平台查询请求，分页参数校验，type类型校验 0,1,2,3,4 或者为null; 转译name、key模糊查询.

2. 查询REPOSITORY对应库信息。（不返回库成员数量）

3. 返回封装结果

##### 6.4 业务逻辑实现

1. controller接口

```java
/**
     * 分页查询face库信息.
     *
     * @param start 从第几个结果开始返回,最小值为1，不填默认为1
     * @param limit 返回至多多少结果，最大值为1024，不填默认为512
     * @param type  库类型
     * @param name  人像库名称，支持模糊查询，即支持前向匹配、后向匹配、中间匹配
     * @param key   人像库名称或者描述的模糊查询，支持前向匹配、后向匹配、中间匹配（人像大数据平台使用）；当name不为空时，以name为主
     * @return 人像库分页信息
     * @throws AppException 检验失败时
     */
    @GetMapping("/repositories")
    @AuthEnable
    public ResponseEntity<Object> queryAll(
            @RequestParam(value = "start", defaultValue = "1") Integer start,
            @RequestParam(value = "limit", defaultValue = "512") Integer limit,
            @RequestParam(value = "type", required = false) String type,
            @RequestParam(value = "name", required = false) String name,
            @RequestParam(value = "key", required = false) String key) throws AppException {
        
        // 1,2,3,4 校验
        result = queryFaceSetService.queryAll(start, limit, type, name, key);
        return ResponseUtil.genResponse(result);
    }
```

2. service 业务 `queryFaceSetService.queryAll(start, limit, type, name, key);`

```java
/**
     * 根据库类型、名称分页查询库信息，支持库名称的模糊查询。(注：车辆抓拍库不返回，只返回face相关的库).
     *
     * @param start 起始
     * @param limit 最多
     * @param type  库类型
     * @param name  库名称
     * @param key   关键字（身份证或者名字）
     * @return 满足条件库列表.
     * @throws AppException 异常返回.
     */
public ServiceResponse queryAll(Integer start, Integer limit, String type,
                                String name, String key) throws AppException {
    try {
        // 参数进行转义// 特殊字符拼接sql是否存在问题？待确认
        // name = "%" + name + "%";
        name = decodeQueryParam(name);
        key = decodeQueryParam(key);
        List<String> repTypes = null;
        if (StringUtils.isNotBlank(type)) {
            repTypes = Arrays.asList(type.split(","));
        }

        result = repositoryService.queryAll(start, limit, repTypes, name,
                                            key, BusinessType.FACE.getCode());
        return ServiceResponse.build(HttpStatus.OK, result, true);
    } 
}
```

` repositoryService.queryAll`()

```java
/*
     * 查询库信息
     */
@Override
public JSONObject queryAll(Integer start, Integer limit,
                           List<String> repTypes, String name, String key,
                           Integer businessType) throws DaoException {
    AuthInfo authInfo = authentication.getCurrentAccount();
    try {
        JSONObject result = new JSONObject();
        // 分页查询
        List<RepositorySearchInfoUnCount> repositoryList = repositoryDao
            .queryAll(start - 1, limit, repTypes, name, key,
                      businessType, authInfo.getUserId());
        if (CollectionUtils.isEmpty(repositoryList)) {
            result.put("totalCount", 0);
            result.put("results", new ArrayList<RepositorySearchInfo>());
        } else {
            result.put("results", repositoryList);
            result.put("totalCount", repositoryList.get(0).getTotalCount());
        }
        return result;

}
```

```java
public List<RepositorySearchInfoUnCount> queryAll(Integer start, Integer limit,
                                                  @Param("repositoryRecordTypes") List<String> repositoryRecordTypes,
                                                  String name, String key, Integer businessType, Integer uid) {
    return repositoryExtMapper
        .selectAllRepositoryByParam(start, limit, repositoryRecordTypes, name, key,
                                    businessType, uid);
}
```

mapper.xml

```xml
 <select id="selectAllRepositoryByParam" resultMap="RepositoryResultMapUnCount">
        select REPOSITORY_ID,REPOSITORY_RECORD_ID,REPOSITORY_NAME,REPOSITORY_TYPE,MEMO,CREATETIME,
        (select count(*) from REPOSITORY where STATE >= 0
        <if test="repositoryTypes !=null">
            AND
            REPOSITORY_TYPE in
            <foreach collection="repositoryTypes" item="repositoryType"
                     open="(" close=")" separator=",">
                #{repositoryType}
            </foreach>
        </if>
        <if test="name !=null">
            AND
            REPOSITORY_NAME LIKE #{name,jdbcType=VARCHAR}
        </if>
        <if test="name ==null">
            <if test="key !=null">
                AND
                (REPOSITORY_NAME LIKE #{key,jdbcType=VARCHAR}
                OR
                MEMO LIKE #{key,jdbcType=VARCHAR})
            </if>
        </if>
        <if test="businessType !=null">
            AND
            BUSINESS_TYPE= #{businessType, jdbcType=INTEGER}
        </if>
        <if test="uid !=null">
            AND
            UID LIKE #{uid,jdbcType=VARCHAR}
        </if>
        ) as TOTAL_COUNT
        from REPOSITORY
        where STATE >= 0
        <if test="repositoryTypes !=null">
            AND
            REPOSITORY_TYPE in
            <foreach collection="repositoryTypes" item="repositoryType"
                     open="(" close=")" separator=",">
                #{repositoryType}
            </foreach>
        </if>
        <if test="name !=null">
            AND
            REPOSITORY_NAME LIKE #{name,jdbcType=VARCHAR}
        </if>
        <if test="name ==null">
            <if test="key !=null">
                AND
                (REPOSITORY_NAME LIKE #{key,jdbcType=VARCHAR}
                OR
                MEMO LIKE #{key,jdbcType=VARCHAR})
            </if>
        </if>
        <if test="businessType !=null">
            AND
            BUSINESS_TYPE= #{businessType, jdbcType=INTEGER}
        </if>
        <if test="uid !=null">
            AND
            UID LIKE #{uid,jdbcType=VARCHAR}
        </if>
        LIMIT #{start,jdbcType=INTEGER}, #{limit,jdbcType=INTEGER}
    </select>
```

#### 7. 批量查看库信息（只看0，1，2）

##### 7.1 时序图

![image-20240718161921668](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718161921668.png)

##### 7.2 关键路径流程图

![image-20240718161946272](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718161946272.png)

##### 7.3 实现逻辑描述

1. Saas下发批量查询库信息，分页参数校验。查询类型校验，

2. 根据是否存在recordId确定精确查询或模糊查询

3. 封装返回结果

##### 7.4 业务逻辑实现

1. controller接口

```java
/**
     * 批量查看人像库.
     */
@PostMapping("/repository/queries")
@AuthEnable
public ResponseEntity<Object> queryFaceSetInfo(@RequestBody QueryFaceSetBean queryFaceSetBean)
    throws AppException {
    queryFaceSetBean.doQueryRequestVerify();
    ServiceResponse result = queryFaceSetService.queryFaceSetInfo(queryFaceSetBean);
    return ResponseUtil.genResponse(result);

}
```

2. service 层

```java
/**
     * 查询库信息.
     *
     * @param bean 查询条件.
     * @return 库信息列表.
     */
public ServiceResponse queryFaceSetInfo(QueryFaceSetBean bean) {
    try {
        AuthInfo authInfo = authentication.getCurrentAccount();
        List<RepositorySetInfo> repositorySetInfoList = repositoryDao
            .queryFaceSetInfo(bean.getIds(), bean.getStart(),
                              bean.getLimit(), bean.getType(), bean.getName(),
                              bean.getKey(), authInfo.getUserId());
}
```

`repositoryDao.queryFaceSetInfo()`

```java
public List<RepositorySetInfo> queryFaceSetInfo(List<String> ids, Integer start, Integer limit,
                                                Integer type, String name, String key, Integer uid) throws DaoException {
    try {
        if (CollectionUtils.isNotEmpty(ids)) {
            List<RepositorySetInfo> repositorySetInfos = repositoryExtMapper
                .selectFaceSetInfoByIds(ids, uid);
            if (CollectionUtils.isNotEmpty(repositorySetInfos)
                && repositorySetInfos.size() != ids.size()) {
                log.error(
                    "query ids size is ({}), but mysql return size is ({}), maybe some repositoryId do not belong uid ({})",
                    ids.size(), repositorySetInfos.size(), uid);
            }
            return repositorySetInfos;
        } else {
            return repositoryExtMapper
                .selectFaceSetInfo(start - 1, limit, type, name, key, uid);
        }
    } 
}
```

只能查 0，1，2库

* 如果 ids不为空，就是制定了表id，则根据id来查询

```
repositoryExtMapper.selectFaceSetInfoByIds(ids, uid);
```

```xml
<select id="selectFaceSetInfoByIds" resultMap="FaceSetResultMap">
        select REPOSITORY_ID,REPOSITORY_RECORD_ID,REPOSITORY_NAME,REPOSITORY_TYPE,MEMO,CREATETIME
        from REPOSITORY
        where STATE >= 0 AND REPOSITORY_TYPE IN (0, 1, 2)
        AND REPOSITORY_RECORD_ID IN
        <foreach collection="repostioryRecordIds" item="repostioryRecordId" open="(" separator=","
                 close=")">
            #{repostioryRecordId,jdbcType=VARCHAR}
        </foreach>
        <if test="uid !=null">
            AND UID = #{uid,jdbcType=INTEGER}
        </if>
        AND BUSINESS_TYPE = 0
    </select>
```

* 如果id为空，则根据其它条件查询

```
 repositoryExtMapper.selectFaceSetInfo(start - 1, limit, type, name, key, uid);
```

```xml
<select id="selectFaceSetInfo" resultMap="FaceSetResultMap">
        select REPOSITORY_ID,REPOSITORY_RECORD_ID,REPOSITORY_NAME,REPOSITORY_TYPE,MEMO,CREATETIME
        from REPOSITORY
        where STATE >= 0 and REPOSITORY_TYPE IN (0, 1, 2)
        <if test="type !=null">
            AND
            REPOSITORY_TYPE = #{type,jdbcType=INTEGER}
        </if>
        <if test="name !=null and name != ''">
            AND
            REPOSITORY_NAME LIKE #{name,jdbcType=VARCHAR}
        </if>
        <if test="name ==null or name == ''">
            <if test="key !=null and key != ''">
                AND
                (REPOSITORY_NAME LIKE #{key,jdbcType=VARCHAR}
                OR
                MEMO LIKE #{key,jdbcType=VARCHAR})
            </if>
        </if>
        <if test="uid !=null">
            AND UID = #{uid,jdbcType=INTEGER}
        </if>
        AND BUSINESS_TYPE = 0
        LIMIT #{start,jdbcType=INTEGER}, #{limit,jdbcType=INTEGER}
    </select>
```

#### 8. 查看人像库图片信息 (只是查询了图片数量信息，和上面逻辑相同)

##### 8.1 时序图

![image-20240718163430859](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718163430859.png)

##### 8.2  关键路径流程图

![image-20240718163459386](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240718163459386.png)

##### 8.3 实现逻辑描述

1. SaaS平台请求查询人像库图片信息，参数校验，库id不能为空

2. 校验库id是否存在，不存在返回异常

3. 存在库id,判断是否开启云存，开启云存，则云库查询库图片信息

4. 未开启云存，则查询

5. 返回封装结果

##### 8.4 业务逻辑实现

1. controller接口

```java
/**
     * 查看人像库图片信息.
     */
@PostMapping("/repository/picture")
@AuthEnable
public ResponseEntity<Object> queryFaceSetPicCount(
    @RequestBody QueryFaceSetBean queryFaceSetBean) throws AppException {
    queryFaceSetBean.doQueryFaceSetPicCountVerify();
    // 
    ServiceResponse result = queryFaceSetService
        .queryFaceSetPicCount(queryFaceSetBean.getIds());
    return ResponseUtil.genResponse(result);
}
```

2. service层

```
queryFaceSetService.queryFaceSetPicCount(queryFaceSetBean.getIds());
```

```java
/**
     * 根据库ID列表，批量查询库中图片信息. (数量)
     * @param repositoryRecordIds 库记录ID列表.
     * @return 库信息记录.
     */
public ServiceResponse queryFaceSetPicCount(List<String> repositoryRecordIds) {
    try {
       
        List<RepositorySetPicCount> picCounts = new ArrayList<>();
        // 对人像库ID进行过滤 - 库ID必须是0,1,2的库类型，业务类型为face
        List<RepositorySetInfo> faceSets = repositoryDao.queryFaceSetInfo(
            repositoryRecordIds, 1, null, null, null, null, authInfo.getUserId());
        
        Map<String, Integer> repoMemberCount = new HashMap<>();
        if (CollectionUtils.isEmpty(faceSets)) {
            // 不存在有效的库ID
        } else {
            // 存在满足条件的人像库ID
            List<String> faceRecordIds = faceSets.stream()
                .collect(Collectors.mapping(
                    RepositorySetInfo::getRepositoryRecordId,
                    Collectors.toList()));
            repoMemberCount = repositoryService.queryFaceSetPicCount(faceRecordIds);
        }
        // 将库对应的库成员个数信息封装到结果中
        for (String id : repositoryRecordIds) {
            Integer count = repoMemberCount.get(id);

            picCounts.add(RepositorySetPicCount.builder().id(id)
                          .totalPictureCount(count).build());
        }
        RepositorySetPicCountResult repositorySetPicCountResult = RepositorySetPicCountResult
            .builder().results(picCounts).build();
        return ServiceResponse.build(HttpStatus.OK,
                                     repositorySetPicCountResult, true);
    } 
}
```

`repoMemberCount = repositoryService.queryFaceSetPicCount(faceRecordIds);`

```java
/*
     * 根据库ID列表，批量查询库中图片信息
     */
@Override
public Map<String, Integer> queryFaceSetPicCount(
    List<String> repositoryRecordIds) throws Exception {
    // 根据库ID查询库成员个数信息
    return queryRepositoryMemberCount(repositoryRecordIds);
}
```

从云数据库查询对应的图片数量

`repoMembers = queryDseMemberCount(repositoryRecordIds);`



### 2. 步态库业务功能 （整体逻辑与人像库业务一致）

#### 2.1 新建步态库

步骤和流程与创建人像库一致，都是使用了 	`repositoryCenterService.create` 方法

##### 2.1.1 时序图

![image-20240719101122505](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240719101122505.png)

##### 2.1.2 关键路径流程图

![image-20240719101137237](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240719101137237.png)

##### 2.1.3 实现逻辑描述

1. Saas请求创建步态库，校验参数，库类型为0,1,2,3,4否则抛出异常。

2. 业务数据校验,是否存在相同的库id，存在则返回失败。

3. 将库信息写入REPOSITORY表，将脱敏库id和主键库id的映射关系、库资源关系写入内存



#### 2.2 修改步态库

##### 2.2.1 时序图

![image-20240719101324951](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240719101324951.png)

##### 2.2.2 关键路径流程图

![image-20240719101332995](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240719101332995.png)

##### 2.2.3 实现逻辑描述

1. SaaS平台下发修改任务，校验参数，name,memo长度不超过128 

2. 根据repositoryRecordId查询数据库表REPOSITORY记录，如果不存在，返回异常。

3. 判断是否为黑白名单库，且是否修改库名称。

   3.1 是  修改步态库名称，并请求Excutor同步路由

   3.2 否  修改步态库信息

4. 返回



#### 2.3 分页查询步态库

##### 2.3.1 时序图

![image-20240719101501594](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240719101501594.png)

##### 2.3.2 关键路径流程图

![image-20240719101514767](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240719101514767.png)

##### 2.3.3 实现逻辑描述

1. Saas下发步态库查询参数，校验分页参数。Id数组大小小于1024,name支持后模糊查询

2. Ids存在时忽略type和name，校验id是否都存在于REPOSITORY表中类型为0,1,2

3. 返回查询结果



#### 2.4 删除步态库

##### 2.4.1 时序图

![image-20240719101619828](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240719101619828.png)



##### 2.4.2 关键路径流程图

![image-20240719101628125](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240719101628125.png)

##### 2.4.3 实现逻辑描述



1. SaaS平台下发删除任务，校验参数RecordId不能为空。

2. 查询REPOSITORY表中记录是否存在RecordId是否存在。

3. 判断是否存在该步态库，则判断该步态库是否被 布控任务（SURVEILLANCE表）、通道分析（CHANNEL_ANALYSIS表）、NVN任务（NVN_JOB表）使用。

4. 如果步态库在使用，抛出异常，正在使用，不可删除，不在使用跟新REPOSITORY.STATE、REPOSITORY_RESOURCE. OPERATION_STATE状态-2

5. 删除内存缓存，库id信息缓存，库资源关系缓存。

6. 返回成功

7. 后台线程执行清理动作



### 3 库资源管理功能

#### 3.1 绑定资源关系

##### 3.1.1 流程图

<img src="C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240719101913464.png" alt="image-20240719101913464" style="zoom:150%;" />

##### 3.1.2 流程描述

1、 创建库，根据库类型创建对应的库或分片

2、 根据库类型查询需要绑定的算子资源

3、 将库绑定关系持久化到mysql

4、 写入内存

注意点：

(1)  静态库可能只是添加一个库Id,并不会创建分片，这时候我们只把key保存在Map中，value是空. 这么做只是为了让DP动作统一，实际上保存这个没有其他作用。

(2)  查询资源的方式：

布控库：查询单个状态为(1,6) ，剩余能力最多的检索算子，(1,3,6)的所有告警算子。

静态库：查询单个状态为(1,6) ，剩余能力最多的检索算子。

抓拍库：查询单个状态为(1,3,6)的检索算子。

(3)  添加布控库，需要和所有的告警绑定

(4)  存在的问题：

只有一个告警算子也可以添加布控库成功，这样会导致不能选择这个库进行检索。



##### 3.1.3 业务逻辑实现

* 主要接口 `public interface IRepositoryResourceHandle {}`

```java
/**
 * 添加库-资源关系,静态库需要返回一个RepositoryShard信息，知道创建的分片
 */
List<RepResource> addRepositoryResourceInfo(AddRepResourceRequest request) throws DaoException;
/** public class AddRepResourceRequest {
    private List<String> repositoryIds;
    private Integer repositoryType;
    private Integer businessType;
    private Boolean createShard;
    private Integer shardMaxSize;
    private String uid;
    private Integer dataSource;
} */
```



* 获取资源，实际在子类根据业务类型去获取  （有17个子类实现）

  `protected abstract List<ResourceInfo> getResources(int businessType, Integer repositoryNum)`

  * 不同的业务有不同的实现

资源类型有 running、shutdown、pending、pre_running、loading

```java
public enum ResourceState {
    RESOURCE_RUNNING_STATE(1),
    RESOURCE_SHUTDOWN_STATE(2),
    RESOURCE_PENDING_STATE(3),
    RESOURCE_PRE_RUNNING_STATE(4),
    RESOURCE_LOADING_STATE(6),;
}
```

```java
@Override
protected List<ResourceInfo> getResources(int businessType, Integer repositoryNum) throws AppException {
    log.info("to query resource {}", FACE_ALARM_TYPE.getName());
    List<ResourceInfo> resourceInfos = new ArrayList<>();
    // 检索算子 布控库（黑白名单） 1 6
    Integer[] retrivalResourceStates = new Integer[]{RESOURCE_RUNNING_STATE.getValue(), RESOURCE_LOADING_STATE.getValue()};
    // 告警算子 布控库（黑白名单） 1 3 6
    Integer[] alarmResourceStates = new Integer[]{RESOURCE_RUNNING_STATE.getValue(), RESOURCE_PENDING_STATE.getValue(), RESOURCE_LOADING_STATE.getValue()};
    // 先获取告警算子
    FilterParameter filterParameter = FilterParameter.builder().deviceStates(alarmResourceStates).availableDeviceTypes(new Integer[]{FACE_ALARM_TYPE.getType()}).build();

    // 根据自定义的资源类型获取可用资源
    ResourceWrapper<List<ResourceInfo>> listResourceWrapper = resourceCenterService.getAvailableResourceWithCustomSelector(filterParameter, null, 0);
    if (!listResourceWrapper.isHasWorkableResource() && listResourceWrapper.getErrorEnum().equals(RESOURCE_UNAVAILABLE)) {
        // 请求资源管理中心异常
        throw new AppException(RESOURCE_UNAVAILABLE);
    }
    // 有可用资源
    if (listResourceWrapper.isHasWorkableResource()) {
        // 将资源加入到 resourceInfos
        resourceInfos.addAll(listResourceWrapper.getWorkableResource());
    }
    // 再获取检索资源
    filterParameter = FilterParameter.builder().deviceStates(retrivalResourceStates).availableDeviceTypes(new Integer[]{FACE_RETRIEVAL_MATCH_TYPE.getType()}).build();
    ResourceWrapper<List<ResourceInfo>> resourceWrapper = resourceCenterService.getAvailableResourceWithCustomSelector(filterParameter, AllocationStrategy.SHARD_STRATEGY, 1);

    if (!resourceWrapper.isHasWorkableResource() && resourceWrapper.getErrorEnum().equals(RESOURCE_UNAVAILABLE)) {
        // 请求资源管理中心异常
        throw new AppException(RESOURCE_UNAVAILABLE);
    }
    // 没有获取到正在运行的（RUNNING）检索算子资源，如果找到PENDING的算子资源，报没有空闲异常
    if (!resourceWrapper.isHasWorkableResource() && !resourceWrapper.getErrorEnum().equals(RESOURCE_UNAVAILABLE)) {
        // 找 PENDING状态的算子资源
        filterParameter = FilterParameter.builder().deviceStates(new Integer[]{RESOURCE_PENDING_STATE.getValue()}).availableDeviceTypes(new Integer[]{FACE_RETRIEVAL_MATCH_TYPE.getType()}).build();
        ResourceWrapper<List<ResourceInfo>> offLineResources = resourceCenterService.getAvailableResourceWithCustomSelector(filterParameter, null, 1);
        if (!offLineResources.isHasWorkableResource() && offLineResources.getErrorEnum().equals(RESOURCE_UNAVAILABLE)) {
            // 请求资源管理中心异常
            throw new AppException(RESOURCE_UNAVAILABLE);
        }
        // 没有空闲的资源
        if (offLineResources.isHasWorkableResource()) {
            throw new AppException(NO_FREE_RESOURCE);
        }
    }
    if (resourceWrapper.isHasWorkableResource()) {
        // 取第一个资源
        resourceInfos.add(resourceWrapper.getWorkableResource().get(0));
    }
    return resourceInfos;
}
```

* 获取资源的流程是：1.构建检索filterParameter，利用GRPC去请求获取；2.根据请求结果，将可用的算子资源保存在resourcesInfos列表中，返回。



以下代码的limit作用？

```
ResourceWrapper<List<ResourceInfo>> resourceWrapper = resourceCenterService.getAvailableResourceWithCustomSelector(filterParameter, null, limit);
```



```java 
//com/dahuatech/cvengine/perception/core/repositoryResourceManage/handler/BaseRepositoryResourceHandle.java
addRepositoryResourceInfo 这个函数很重要，将加载的资源保存
```





```java
@Override
public List<RepResource> addRepositoryResourceInfo(AddRepResourceRequest request) throws DaoException {

    String uid = request.getUid();
    int businessType = request.getBusinessType();
    int dataSource = request.getDataSource();
    int repositoryType = request.getRepositoryType();
    int shardMaxSize = request.getShardMaxSize() == null ? 0 : request.getShardMaxSize();
    List<RepResource> repResourceList = Lists.newArrayList();

    // 静态库，没有创建分片
    if (request.getCreateShard() != null && !request.getCreateShard() && STATIC.getValue().equals(request.getRepositoryType())) {
        log.info("repositoryType is static and don not create shard! return success");
        //静态库若是添加了，但是没创建分片，则我们也要保存一下空信息，查询时返回空,直接返回success
        map.putIfAbsent(uid, new ConcurrentHashMap<>(16));
        request.getRepositoryIds().stream().forEach(repositoryId -> map.get(uid).putIfAbsent(repositoryId, new HashSet<>()));
        return repResourceList;
    }

    //1.  获取抓拍库应该查询的资源信息,如果只有一个抓拍库，则只选择一个检索资源；如果有多个抓拍库则选择所有检索资源
    List<ResourceInfo> resourceInfos = getResources(businessType, request.getRepositoryIds().size());
    if (CollectionUtils.isEmpty(resourceInfos) || !isHasRetrievalResource(resourceInfos)) {
        // 如果没有资源，则做响应处理
        processNotResource(uid, dataSource, businessType, repositoryType, request.getRepositoryIds());
    }

    //2. 将抓拍库分配到不同的检索资源中，组成map
    Map<String, Set<ShardToResource>> repoToResMap = bindResToRepo(resourceInfos, request.getRepositoryIds());

    //3. 组建repositoryResource，并批量插入数据库
    Map<Integer, ResourceInfo> resourceInfoMap = resourceInfos.stream().collect(Collectors.toMap(ResourceInfo::getResourceId, Function.identity(), (key1, key2) -> key2));
    saveToDb(repoToResMap, shardMaxSize, resourceInfoMap);
    log.info("add capture repositoryResource info to DB success!!!!");

    //5. 保存到内存中
    saveCache(uid, repoToResMap);

    //6. 处理返回结果，目前只有静态库需要处理返回结果
    doResult(repoToResMap, repResourceList, resourceInfos);

    //7. 推库处理，目前只有冷搜算子需要推库
    pushRepository(repoToResMap, resourceInfos);
    return repResourceList;
}
```





* `AbstractStub`类提供了基础的RPC调用逻辑，包括连接管理、序列化/反序列化、错误处理等。它还提供了方法来构建和配置客户端存根，比如设置Channel、CallOptions等。通过继承`AbstractStub`，子类可以专注于实现具体的RPC方法，而不需要关心底层的通信细节。
* `withDeadlineAfter`方法帮助你管理RPC调用的超时时间，这对于处理那些可能长时间运行或不可预测的服务响应非常重要。它确保了客户端不会无休止地等待，提高了应用程序的健壮性和用户体验。当RPC调用超时被取消时，gRPC框架会释放与该调用相关的资源，如网络连接和线程，避免资源泄露。超时后，gRPC会抛出一个`Status.DEADLINE_EXCEEDED`异常，这可以帮助你识别哪些服务调用可能存在问题，比如性能瓶颈或服务不可用。



##### 3.1.4 绑定资源关系——流程梳理

新建人像库和步态库都会执行`repositoryResourceAllServiceImpl.insert(repository, businessType, dataSource);` 该方法中有一行执行`addRepoToTaskManager()`方法，该方法的底层就是执行库资源关系绑定；

```java
@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)
public Repository insert(Repository repository, int businessType, Integer dataSource) throws Exception {
    if (null == repository) {
        return null;
    }
    repositoryExtMapper.insert(repository);
    // 库资源绑定
    addRepoToTaskManager(String.valueOf(repository.getRepositoryId()), repository.getRepositoryType(), false, businessType, dataSource, repository.getUid());
    return repository;
}
```

分析 `addRepoToTaskManager()`方法；重点在 `repResourceList = repositoryResourceService.addRepositoryResource(addRepResourceRequest);` 

```
@Override
public List<RepResource> addRepositoryResource(AddRepResourceRequest request) throws DaoException {
    //1: 参数校验
    //2: 获取业务处理类
    List<IRepositoryResourceHandle> handles = getBusinessTypeHandles(request.getBusinessType(), request.getRepositoryType(), request.getDataSource());

    //3: 业务处理  异常这里不处理，交给上层捕获
    List<RepResource> shardResources = Lists.newArrayList();
    for (IRepositoryResourceHandle handle : handles) {
        // 绑定资源关系 addRepositoryResourceInfo（）
        shardResources.addAll(handle.addRepositoryResourceInfo(request));
    }
    return shardResources;
}
```

* 首先获取业务处理类，不同的业务有不同的业务实现；
* 获取到业务处理类handles后，会执行`handle.addRepositoryResourceInfo(request)` 方法，该方法是库资源绑定的关键，具体的绑定细节都在该方法中执行；

**进入`handle.addRepositoryResourceInfo(request)` 方法 **

```java
@Override
public List<RepResource> addRepositoryResourceInfo(AddRepResourceRequest request) throws DaoException {

    String uid = request.getUid();
    int businessType = request.getBusinessType();
    int dataSource = request.getDataSource();
    int repositoryType = request.getRepositoryType();
    int shardMaxSize = request.getShardMaxSize() == null ? 0 : request.getShardMaxSize();
    List<RepResource> repResourceList = Lists.newArrayList();

    // 静态库，没有创建分片
    if (request.getCreateShard() != null && !request.getCreateShard() && STATIC.getValue().equals(request.getRepositoryType())) {
        log.info("repositoryType is static and don not create shard! return success");
        //静态库若是添加了，但是没创建分片，则我们也要保存一下空信息，查询时返回空,直接返回success
        map.putIfAbsent(uid, new ConcurrentHashMap<>(16));
        request.getRepositoryIds().stream().forEach(repositoryId -> map.get(uid).putIfAbsent(repositoryId, new HashSet<>()));
        return repResourceList;
    }

    //1.  获取抓拍库应该查询的资源信息,如果只有一个抓拍库，则只选择一个检索资源；如果有多个抓拍库则选择所有检索资源
    List<ResourceInfo> resourceInfos = getResources(businessType, request.getRepositoryIds().size());
    if (CollectionUtils.isEmpty(resourceInfos) || !isHasRetrievalResource(resourceInfos)) {
        // 如果没有资源，则做响应处理
        //  log.info("get resource is null, so save repository to DB UNPROCESS_REPOSITORY !!!!");
        processNotResource(uid, dataSource, businessType, repositoryType, request.getRepositoryIds());
    }

    //2. 将抓拍库分配到不同的检索资源中，组成map
    Map<String, Set<ShardToResource>> repoToResMap = bindResToRepo(resourceInfos, request.getRepositoryIds());

    //3. 组建repositoryResource，并批量插入数据库
    Map<Integer, ResourceInfo> resourceInfoMap = resourceInfos.stream().collect(Collectors.toMap(ResourceInfo::getResourceId, Function.identity(), (key1, key2) -> key2));
    saveToDb(repoToResMap, shardMaxSize, resourceInfoMap);
    log.info("add capture repositoryResource info to DB success!!!!");

    //5. 保存到内存中
    saveCache(uid, repoToResMap);

    //6. 处理返回结果，目前只有静态库需要处理返回结果
    doResult(repoToResMap, repResourceList, resourceInfos);

    //7. 推库处理，目前只有冷搜算子需要推库
    pushRepository(repoToResMap, resourceInfos);
    return repResourceList;
}
```

执行流程与业务描述一致

1. 创建库，根据库类型创建对应的库或分片
2. 根据库类型查询需要绑定的算子资源
3. 将库绑定关系持久化到mysql
4. 写入内存

注意点：

(1)  静态库可能只是添加一个库Id,并不会创建分片，这时候我们只把key保存在Map中，value是空. 这么做只是为了让DP动作统一，实际上保存这个没有其他作用。

(2)  查询资源的方式：

布控库：查询单个状态为(1,6) ，剩余能力最多的检索算子，(1,3,6)的所有告警算子。

静态库：查询单个状态为(1,6) ，剩余能力最多的检索算子。

抓拍库：查询单个状态为(1,3,6)的检索算子。

(3)  添加布控库，需要和所有的告警绑定

(4)  存在的问题：

只有一个告警算子也可以添加布控库成功，这样会导致不能选择这个库进行检索。



#### 3.2 推库功能





### 4. 库成员管理

#### 4.1 功能描述

为了查询检索，将成员记录导入库中，同时提取每个成员的特征记录，便于后续的特征比对计算相似性进行检索。功能包含：

1. 添加：库成员图片存入Feature固态存储，对于后端智能——将图片发往分析算子提取特征，特征写入Feature固态存储，同时特征实时添加进检索、告警算子，最后记录写入mysql或发往云数据库的MQ进行固态存储；

2. 删除：由于成员图片业务层还需要用到，如历史告警原图展示，因此删除成员时，不进行图片删除，只删除成员记录（mysql或者CloudDB）及算子内存加载、Feature固态存储的特征

3. 修改：修改mysql、CloudDB或者前端智能上的记录数据 

4. 查询：根据查询条件从mysql或者CloudDB中查询成员记录数据

约束条件：recordId必须唯一



#### 4.2 人像库——新增库成员

添加库成员保存在sql的逻辑，是否需要删除。很少有项目保存在mysql，但是如果去掉，没有云库，库成员是否就会添加失败。

##### 4.2.1 时序图

![image-20240723091403455](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240723091403455.png)

##### 4.2.2 流程图

![image-20240723091425574](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240723091425574.png)

##### 库信息补全和参数转换

![image-20240723091540003](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240723091540003.png)

##### 特征添加和广播

![image-20240723091642016](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240723091642016.png)

##### 库成员持久化

**库成员成功计数**

![image-20240723091707111](C:\Users\485322\AppData\Roaming\Typora\typora-user-images\image-20240723091707111.png)

##### 流程描述

1    接收到Saas服务下发添加库成员请求。

2    **服务状态检查**：检测mysql以及mq状态，如异常返回异常

**3**    **参数校验**

4    **参数转换**：将下发参数repositoryId（对应数据库REPOSITORY. REPOSITORY_RECORD_ID）转换成内部使用的repositoryId（对应数据库REPOSITORY. REPOSITORY_ID）

5    **图片转存**：如果是图片添加库成员，在开启静态库智能存储的条件下，将图片url给到feature转存

6    **库信息补全**：静态库添加库成员，需要获取静态库分片。如果分片不存在，或已存在分片都大于等于阈值，则需要创建新的静态库分片，并绑定库资源关系；如果分片存在且小于分片阈值，选取剩余容量最小分片。

7    **特征提取：**如果使用特征添加库成员，则向Feature存储特征；如果使用图片添加库成员，则向分析算子提取特征，（如需存储特征）向Feature存储特征。

8    **特征存储：**向Feature请求添加特征，失败记录相应错误码和错误信息，成功则向算子广播库成员特征。

9    **特征广播：**将提取的特征通过rpc请求广播给算子，成功则持久化库成员，失败则写入Mysql FEATURE_TO_BROADCAST、FEATURE_TO_RESOURCE表，交由后台线程处理。

10   **库成员持久化：**

**10.1** **本地mysql持久化：**将库成员写入member表，完成

**10.2** **云库持久化：**将库成员通过mq消息或者使用云库http接口保存库成员信息。

11   **返回添加结果。**



**异常点处理**及影响：

l 基础环境检查

MQ及MYSQL任一异常，则直接返回导库失败，强依赖

l 异常点一：算子实时特征存储失败

处理方式：写表，每天凌晨执行，记录url走重提

l 异常点二：CloudDB存储失败

处理方式：返回失败，单独写失败日志，该日志不设置生命周期

影响：

a)   算子内存空间占用

b)  检索：以图搜图算子有返回，若设置face.is.return.op.result=false，补齐时云数据库无法查询则不对外展示，则对结果无影响；若设置face.is.return.op.result=true，则会返回无结构化数据的记录；该配置默认为true；

c)   查询：无影响

d)  告警：无影响，Executor信息补全失败则不告警

l 异常点三：mysql存储失败

处理方式：同异常点二

影响：同异常点二

